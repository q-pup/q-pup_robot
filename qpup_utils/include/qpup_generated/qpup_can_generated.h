/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 37.0.6 Sun Mar  6 13:59:27 2022.
 */

#ifndef QPUP_H
#define QPUP_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define QPUP_ODRIVE_HEARTBEAT_FRAME_ID (0x01u)
#define QPUP_ODRIVE_ESTOP_FRAME_ID (0x02u)
#define QPUP_ODRIVE_GET_MOTOR_ERROR_FRAME_ID (0x03u)
#define QPUP_ODRIVE_GET_ENCODER_ERROR_FRAME_ID (0x04u)
#define QPUP_ODRIVE_GET_SENSORLESS_ERROR_FRAME_ID (0x05u)
#define QPUP_ODRIVE_SET_AXIS_NODE_ID_FRAME_ID (0x06u)
#define QPUP_ODRIVE_SET_AXIS_STATE_FRAME_ID (0x07u)
#define QPUP_ODRIVE_GET_ENCODER_ESTIMATES_FRAME_ID (0x09u)
#define QPUP_ODRIVE_GET_ENCODER_COUNT_FRAME_ID (0x0au)
#define QPUP_ODRIVE_SET_CONTROLLER_MODE_FRAME_ID (0x0bu)
#define QPUP_ODRIVE_SET_INPUT_POS_FRAME_ID (0x0cu)
#define QPUP_ODRIVE_SET_INPUT_VEL_FRAME_ID (0x0du)
#define QPUP_ODRIVE_SET_INPUT_TORQUE_FRAME_ID (0x0eu)
#define QPUP_ODRIVE_SET_LIMITS_FRAME_ID (0x0fu)
#define QPUP_ODRIVE_START_ANTICOGGING_FRAME_ID (0x10u)
#define QPUP_ODRIVE_SET_TRAJ_VEL_LIMIT_FRAME_ID (0x11u)
#define QPUP_ODRIVE_SET_TRAJ_ACCEL_LIMITS_FRAME_ID (0x12u)
#define QPUP_ODRIVE_SET_TRAJ_INERTIA_FRAME_ID (0x13u)
#define QPUP_ODRIVE_GET_IQ_FRAME_ID (0x14u)
#define QPUP_ODRIVE_GET_SENSORLESS_ESTIMATES_FRAME_ID (0x15u)
#define QPUP_ODRIVE_REBOOT_FRAME_ID (0x16u)
#define QPUP_ODRIVE_GET_VBUS_VOLTAGE_FRAME_ID (0x17u)
#define QPUP_ODRIVE_CLEAR_ERRORS_FRAME_ID (0x18u)
#define QPUP_ODRIVE_SET_LINEAR_COUNT_FRAME_ID (0x19u)
#define QPUP_ODRIVE_SET_POS_GAIN_FRAME_ID (0x1au)
#define QPUP_ODRIVE_SET_VEL_GAINS_FRAME_ID (0x1bu)
#define QPUP_AXIS_1_HEARTBEAT_FRAME_ID (0x21u)
#define QPUP_AXIS_1_ESTOP_FRAME_ID (0x22u)
#define QPUP_AXIS_1_GET_MOTOR_ERROR_FRAME_ID (0x23u)
#define QPUP_AXIS_1_GET_ENCODER_ERROR_FRAME_ID (0x24u)
#define QPUP_AXIS_1_GET_SENSORLESS_ERROR_FRAME_ID (0x25u)
#define QPUP_AXIS_1_SET_AXIS_NODE_ID_FRAME_ID (0x26u)
#define QPUP_AXIS_1_SET_AXIS_STATE_FRAME_ID (0x27u)
#define QPUP_AXIS_1_GET_ENCODER_ESTIMATES_FRAME_ID (0x29u)
#define QPUP_AXIS_1_GET_ENCODER_COUNT_FRAME_ID (0x2au)
#define QPUP_AXIS_1_SET_CONTROLLER_MODE_FRAME_ID (0x2bu)
#define QPUP_AXIS_1_SET_INPUT_POS_FRAME_ID (0x2cu)
#define QPUP_AXIS_1_SET_INPUT_VEL_FRAME_ID (0x2du)
#define QPUP_AXIS_1_SET_INPUT_TORQUE_FRAME_ID (0x2eu)
#define QPUP_AXIS_1_SET_LIMITS_FRAME_ID (0x2fu)
#define QPUP_AXIS_1_START_ANTICOGGING_FRAME_ID (0x30u)
#define QPUP_AXIS_1_SET_TRAJ_VEL_LIMIT_FRAME_ID (0x31u)
#define QPUP_AXIS_1_SET_TRAJ_ACCEL_LIMITS_FRAME_ID (0x32u)
#define QPUP_AXIS_1_SET_TRAJ_INERTIA_FRAME_ID (0x33u)
#define QPUP_AXIS_1_GET_IQ_FRAME_ID (0x34u)
#define QPUP_AXIS_1_GET_SENSORLESS_ESTIMATES_FRAME_ID (0x35u)
#define QPUP_AXIS_1_REBOOT_FRAME_ID (0x36u)
#define QPUP_AXIS_1_GET_VBUS_VOLTAGE_FRAME_ID (0x37u)
#define QPUP_AXIS_1_CLEAR_ERRORS_FRAME_ID (0x38u)
#define QPUP_AXIS_1_SET_LINEAR_COUNT_FRAME_ID (0x39u)
#define QPUP_AXIS_1_SET_POS_GAIN_FRAME_ID (0x3au)
#define QPUP_AXIS_1_SET_VEL_GAINS_FRAME_ID (0x3bu)
#define QPUP_AXIS_2_HEARTBEAT_FRAME_ID (0x41u)
#define QPUP_AXIS_2_ESTOP_FRAME_ID (0x42u)
#define QPUP_AXIS_2_GET_MOTOR_ERROR_FRAME_ID (0x43u)
#define QPUP_AXIS_2_GET_ENCODER_ERROR_FRAME_ID (0x44u)
#define QPUP_AXIS_2_GET_SENSORLESS_ERROR_FRAME_ID (0x45u)
#define QPUP_AXIS_2_SET_AXIS_NODE_ID_FRAME_ID (0x46u)
#define QPUP_AXIS_2_SET_AXIS_STATE_FRAME_ID (0x47u)
#define QPUP_AXIS_2_GET_ENCODER_ESTIMATES_FRAME_ID (0x49u)
#define QPUP_AXIS_2_GET_ENCODER_COUNT_FRAME_ID (0x4au)
#define QPUP_AXIS_2_SET_CONTROLLER_MODE_FRAME_ID (0x4bu)
#define QPUP_AXIS_2_SET_INPUT_POS_FRAME_ID (0x4cu)
#define QPUP_AXIS_2_SET_INPUT_VEL_FRAME_ID (0x4du)
#define QPUP_AXIS_2_SET_INPUT_TORQUE_FRAME_ID (0x4eu)
#define QPUP_AXIS_2_SET_LIMITS_FRAME_ID (0x4fu)
#define QPUP_AXIS_2_START_ANTICOGGING_FRAME_ID (0x50u)
#define QPUP_AXIS_2_SET_TRAJ_VEL_LIMIT_FRAME_ID (0x51u)
#define QPUP_AXIS_2_SET_TRAJ_ACCEL_LIMITS_FRAME_ID (0x52u)
#define QPUP_AXIS_2_SET_TRAJ_INERTIA_FRAME_ID (0x53u)
#define QPUP_AXIS_2_GET_IQ_FRAME_ID (0x54u)
#define QPUP_AXIS_2_GET_SENSORLESS_ESTIMATES_FRAME_ID (0x55u)
#define QPUP_AXIS_2_REBOOT_FRAME_ID (0x56u)
#define QPUP_AXIS_2_GET_VBUS_VOLTAGE_FRAME_ID (0x57u)
#define QPUP_AXIS_2_CLEAR_ERRORS_FRAME_ID (0x58u)
#define QPUP_AXIS_2_SET_LINEAR_COUNT_FRAME_ID (0x59u)
#define QPUP_AXIS_2_SET_POS_GAIN_FRAME_ID (0x5au)
#define QPUP_AXIS_2_SET_VEL_GAINS_FRAME_ID (0x5bu)
#define QPUP_AXIS_3_HEARTBEAT_FRAME_ID (0x61u)
#define QPUP_AXIS_3_ESTOP_FRAME_ID (0x62u)
#define QPUP_AXIS_3_GET_MOTOR_ERROR_FRAME_ID (0x63u)
#define QPUP_AXIS_3_GET_ENCODER_ERROR_FRAME_ID (0x64u)
#define QPUP_AXIS_3_GET_SENSORLESS_ERROR_FRAME_ID (0x65u)
#define QPUP_AXIS_3_SET_AXIS_NODE_ID_FRAME_ID (0x66u)
#define QPUP_AXIS_3_SET_AXIS_STATE_FRAME_ID (0x67u)
#define QPUP_AXIS_3_GET_ENCODER_ESTIMATES_FRAME_ID (0x69u)
#define QPUP_AXIS_3_GET_ENCODER_COUNT_FRAME_ID (0x6au)
#define QPUP_AXIS_3_SET_CONTROLLER_MODE_FRAME_ID (0x6bu)
#define QPUP_AXIS_3_SET_INPUT_POS_FRAME_ID (0x6cu)
#define QPUP_AXIS_3_SET_INPUT_VEL_FRAME_ID (0x6du)
#define QPUP_AXIS_3_SET_INPUT_TORQUE_FRAME_ID (0x6eu)
#define QPUP_AXIS_3_SET_LIMITS_FRAME_ID (0x6fu)
#define QPUP_AXIS_3_START_ANTICOGGING_FRAME_ID (0x70u)
#define QPUP_AXIS_3_SET_TRAJ_VEL_LIMIT_FRAME_ID (0x71u)
#define QPUP_AXIS_3_SET_TRAJ_ACCEL_LIMITS_FRAME_ID (0x72u)
#define QPUP_AXIS_3_SET_TRAJ_INERTIA_FRAME_ID (0x73u)
#define QPUP_AXIS_3_GET_IQ_FRAME_ID (0x74u)
#define QPUP_AXIS_3_GET_SENSORLESS_ESTIMATES_FRAME_ID (0x75u)
#define QPUP_AXIS_3_REBOOT_FRAME_ID (0x76u)
#define QPUP_AXIS_3_GET_VBUS_VOLTAGE_FRAME_ID (0x77u)
#define QPUP_AXIS_3_CLEAR_ERRORS_FRAME_ID (0x78u)
#define QPUP_AXIS_3_SET_LINEAR_COUNT_FRAME_ID (0x79u)
#define QPUP_AXIS_3_SET_POS_GAIN_FRAME_ID (0x7au)
#define QPUP_AXIS_3_SET_VEL_GAINS_FRAME_ID (0x7bu)
#define QPUP_AXIS_4_HEARTBEAT_FRAME_ID (0x81u)
#define QPUP_AXIS_4_ESTOP_FRAME_ID (0x82u)
#define QPUP_AXIS_4_GET_MOTOR_ERROR_FRAME_ID (0x83u)
#define QPUP_AXIS_4_GET_ENCODER_ERROR_FRAME_ID (0x84u)
#define QPUP_AXIS_4_GET_SENSORLESS_ERROR_FRAME_ID (0x85u)
#define QPUP_AXIS_4_SET_AXIS_NODE_ID_FRAME_ID (0x86u)
#define QPUP_AXIS_4_SET_AXIS_STATE_FRAME_ID (0x87u)
#define QPUP_AXIS_4_GET_ENCODER_ESTIMATES_FRAME_ID (0x89u)
#define QPUP_AXIS_4_GET_ENCODER_COUNT_FRAME_ID (0x8au)
#define QPUP_AXIS_4_SET_CONTROLLER_MODE_FRAME_ID (0x8bu)
#define QPUP_AXIS_4_SET_INPUT_POS_FRAME_ID (0x8cu)
#define QPUP_AXIS_4_SET_INPUT_VEL_FRAME_ID (0x8du)
#define QPUP_AXIS_4_SET_INPUT_TORQUE_FRAME_ID (0x8eu)
#define QPUP_AXIS_4_SET_LIMITS_FRAME_ID (0x8fu)
#define QPUP_AXIS_4_START_ANTICOGGING_FRAME_ID (0x90u)
#define QPUP_AXIS_4_SET_TRAJ_VEL_LIMIT_FRAME_ID (0x91u)
#define QPUP_AXIS_4_SET_TRAJ_ACCEL_LIMITS_FRAME_ID (0x92u)
#define QPUP_AXIS_4_SET_TRAJ_INERTIA_FRAME_ID (0x93u)
#define QPUP_AXIS_4_GET_IQ_FRAME_ID (0x94u)
#define QPUP_AXIS_4_GET_SENSORLESS_ESTIMATES_FRAME_ID (0x95u)
#define QPUP_AXIS_4_REBOOT_FRAME_ID (0x96u)
#define QPUP_AXIS_4_GET_VBUS_VOLTAGE_FRAME_ID (0x97u)
#define QPUP_AXIS_4_CLEAR_ERRORS_FRAME_ID (0x98u)
#define QPUP_AXIS_4_SET_LINEAR_COUNT_FRAME_ID (0x99u)
#define QPUP_AXIS_4_SET_POS_GAIN_FRAME_ID (0x9au)
#define QPUP_AXIS_4_SET_VEL_GAINS_FRAME_ID (0x9bu)
#define QPUP_AXIS_5_HEARTBEAT_FRAME_ID (0xa1u)
#define QPUP_AXIS_5_ESTOP_FRAME_ID (0xa2u)
#define QPUP_AXIS_5_GET_MOTOR_ERROR_FRAME_ID (0xa3u)
#define QPUP_AXIS_5_GET_ENCODER_ERROR_FRAME_ID (0xa4u)
#define QPUP_AXIS_5_GET_SENSORLESS_ERROR_FRAME_ID (0xa5u)
#define QPUP_AXIS_5_SET_AXIS_NODE_ID_FRAME_ID (0xa6u)
#define QPUP_AXIS_5_SET_AXIS_STATE_FRAME_ID (0xa7u)
#define QPUP_AXIS_5_GET_ENCODER_ESTIMATES_FRAME_ID (0xa9u)
#define QPUP_AXIS_5_GET_ENCODER_COUNT_FRAME_ID (0xaau)
#define QPUP_AXIS_5_SET_CONTROLLER_MODE_FRAME_ID (0xabu)
#define QPUP_AXIS_5_SET_INPUT_POS_FRAME_ID (0xacu)
#define QPUP_AXIS_5_SET_INPUT_VEL_FRAME_ID (0xadu)
#define QPUP_AXIS_5_SET_INPUT_TORQUE_FRAME_ID (0xaeu)
#define QPUP_AXIS_5_SET_LIMITS_FRAME_ID (0xafu)
#define QPUP_AXIS_5_START_ANTICOGGING_FRAME_ID (0xb0u)
#define QPUP_AXIS_5_SET_TRAJ_VEL_LIMIT_FRAME_ID (0xb1u)
#define QPUP_AXIS_5_SET_TRAJ_ACCEL_LIMITS_FRAME_ID (0xb2u)
#define QPUP_AXIS_5_SET_TRAJ_INERTIA_FRAME_ID (0xb3u)
#define QPUP_AXIS_5_GET_IQ_FRAME_ID (0xb4u)
#define QPUP_AXIS_5_GET_SENSORLESS_ESTIMATES_FRAME_ID (0xb5u)
#define QPUP_AXIS_5_REBOOT_FRAME_ID (0xb6u)
#define QPUP_AXIS_5_GET_VBUS_VOLTAGE_FRAME_ID (0xb7u)
#define QPUP_AXIS_5_CLEAR_ERRORS_FRAME_ID (0xb8u)
#define QPUP_AXIS_5_SET_LINEAR_COUNT_FRAME_ID (0xb9u)
#define QPUP_AXIS_5_SET_POS_GAIN_FRAME_ID (0xbau)
#define QPUP_AXIS_5_SET_VEL_GAINS_FRAME_ID (0xbbu)
#define QPUP_AXIS_6_HEARTBEAT_FRAME_ID (0xc1u)
#define QPUP_AXIS_6_ESTOP_FRAME_ID (0xc2u)
#define QPUP_AXIS_6_GET_MOTOR_ERROR_FRAME_ID (0xc3u)
#define QPUP_AXIS_6_GET_ENCODER_ERROR_FRAME_ID (0xc4u)
#define QPUP_AXIS_6_GET_SENSORLESS_ERROR_FRAME_ID (0xc5u)
#define QPUP_AXIS_6_SET_AXIS_NODE_ID_FRAME_ID (0xc6u)
#define QPUP_AXIS_6_SET_AXIS_STATE_FRAME_ID (0xc7u)
#define QPUP_AXIS_6_GET_ENCODER_ESTIMATES_FRAME_ID (0xc9u)
#define QPUP_AXIS_6_GET_ENCODER_COUNT_FRAME_ID (0xcau)
#define QPUP_AXIS_6_SET_CONTROLLER_MODE_FRAME_ID (0xcbu)
#define QPUP_AXIS_6_SET_INPUT_POS_FRAME_ID (0xccu)
#define QPUP_AXIS_6_SET_INPUT_VEL_FRAME_ID (0xcdu)
#define QPUP_AXIS_6_SET_INPUT_TORQUE_FRAME_ID (0xceu)
#define QPUP_AXIS_6_SET_LIMITS_FRAME_ID (0xcfu)
#define QPUP_AXIS_6_START_ANTICOGGING_FRAME_ID (0xd0u)
#define QPUP_AXIS_6_SET_TRAJ_VEL_LIMIT_FRAME_ID (0xd1u)
#define QPUP_AXIS_6_SET_TRAJ_ACCEL_LIMITS_FRAME_ID (0xd2u)
#define QPUP_AXIS_6_SET_TRAJ_INERTIA_FRAME_ID (0xd3u)
#define QPUP_AXIS_6_GET_IQ_FRAME_ID (0xd4u)
#define QPUP_AXIS_6_GET_SENSORLESS_ESTIMATES_FRAME_ID (0xd5u)
#define QPUP_AXIS_6_REBOOT_FRAME_ID (0xd6u)
#define QPUP_AXIS_6_GET_VBUS_VOLTAGE_FRAME_ID (0xd7u)
#define QPUP_AXIS_6_CLEAR_ERRORS_FRAME_ID (0xd8u)
#define QPUP_AXIS_6_SET_LINEAR_COUNT_FRAME_ID (0xd9u)
#define QPUP_AXIS_6_SET_POS_GAIN_FRAME_ID (0xdau)
#define QPUP_AXIS_6_SET_VEL_GAINS_FRAME_ID (0xdbu)
#define QPUP_AXIS_7_HEARTBEAT_FRAME_ID (0xe1u)
#define QPUP_AXIS_7_ESTOP_FRAME_ID (0xe2u)
#define QPUP_AXIS_7_GET_MOTOR_ERROR_FRAME_ID (0xe3u)
#define QPUP_AXIS_7_GET_ENCODER_ERROR_FRAME_ID (0xe4u)
#define QPUP_AXIS_7_GET_SENSORLESS_ERROR_FRAME_ID (0xe5u)
#define QPUP_AXIS_7_SET_AXIS_NODE_ID_FRAME_ID (0xe6u)
#define QPUP_AXIS_7_SET_AXIS_STATE_FRAME_ID (0xe7u)
#define QPUP_AXIS_7_GET_ENCODER_ESTIMATES_FRAME_ID (0xe9u)
#define QPUP_AXIS_7_GET_ENCODER_COUNT_FRAME_ID (0xeau)
#define QPUP_AXIS_7_SET_CONTROLLER_MODE_FRAME_ID (0xebu)
#define QPUP_AXIS_7_SET_INPUT_POS_FRAME_ID (0xecu)
#define QPUP_AXIS_7_SET_INPUT_VEL_FRAME_ID (0xedu)
#define QPUP_AXIS_7_SET_INPUT_TORQUE_FRAME_ID (0xeeu)
#define QPUP_AXIS_7_SET_LIMITS_FRAME_ID (0xefu)
#define QPUP_AXIS_7_START_ANTICOGGING_FRAME_ID (0xf0u)
#define QPUP_AXIS_7_SET_TRAJ_VEL_LIMIT_FRAME_ID (0xf1u)
#define QPUP_AXIS_7_SET_TRAJ_ACCEL_LIMITS_FRAME_ID (0xf2u)
#define QPUP_AXIS_7_SET_TRAJ_INERTIA_FRAME_ID (0xf3u)
#define QPUP_AXIS_7_GET_IQ_FRAME_ID (0xf4u)
#define QPUP_AXIS_7_GET_SENSORLESS_ESTIMATES_FRAME_ID (0xf5u)
#define QPUP_AXIS_7_REBOOT_FRAME_ID (0xf6u)
#define QPUP_AXIS_7_GET_VBUS_VOLTAGE_FRAME_ID (0xf7u)
#define QPUP_AXIS_7_CLEAR_ERRORS_FRAME_ID (0xf8u)
#define QPUP_AXIS_7_SET_LINEAR_COUNT_FRAME_ID (0xf9u)
#define QPUP_AXIS_7_SET_POS_GAIN_FRAME_ID (0xfau)
#define QPUP_AXIS_7_SET_VEL_GAINS_FRAME_ID (0xfbu)
#define QPUP_AXIS_8_HEARTBEAT_FRAME_ID (0x101u)
#define QPUP_AXIS_8_ESTOP_FRAME_ID (0x102u)
#define QPUP_AXIS_8_GET_MOTOR_ERROR_FRAME_ID (0x103u)
#define QPUP_AXIS_8_GET_ENCODER_ERROR_FRAME_ID (0x104u)
#define QPUP_AXIS_8_GET_SENSORLESS_ERROR_FRAME_ID (0x105u)
#define QPUP_AXIS_8_SET_AXIS_NODE_ID_FRAME_ID (0x106u)
#define QPUP_AXIS_8_SET_AXIS_STATE_FRAME_ID (0x107u)
#define QPUP_AXIS_8_GET_ENCODER_ESTIMATES_FRAME_ID (0x109u)
#define QPUP_AXIS_8_GET_ENCODER_COUNT_FRAME_ID (0x10au)
#define QPUP_AXIS_8_SET_CONTROLLER_MODE_FRAME_ID (0x10bu)
#define QPUP_AXIS_8_SET_INPUT_POS_FRAME_ID (0x10cu)
#define QPUP_AXIS_8_SET_INPUT_VEL_FRAME_ID (0x10du)
#define QPUP_AXIS_8_SET_INPUT_TORQUE_FRAME_ID (0x10eu)
#define QPUP_AXIS_8_SET_LIMITS_FRAME_ID (0x10fu)
#define QPUP_AXIS_8_START_ANTICOGGING_FRAME_ID (0x110u)
#define QPUP_AXIS_8_SET_TRAJ_VEL_LIMIT_FRAME_ID (0x111u)
#define QPUP_AXIS_8_SET_TRAJ_ACCEL_LIMITS_FRAME_ID (0x112u)
#define QPUP_AXIS_8_SET_TRAJ_INERTIA_FRAME_ID (0x113u)
#define QPUP_AXIS_8_GET_IQ_FRAME_ID (0x114u)
#define QPUP_AXIS_8_GET_SENSORLESS_ESTIMATES_FRAME_ID (0x115u)
#define QPUP_AXIS_8_REBOOT_FRAME_ID (0x116u)
#define QPUP_AXIS_8_GET_VBUS_VOLTAGE_FRAME_ID (0x117u)
#define QPUP_AXIS_8_CLEAR_ERRORS_FRAME_ID (0x118u)
#define QPUP_AXIS_8_SET_LINEAR_COUNT_FRAME_ID (0x119u)
#define QPUP_AXIS_8_SET_POS_GAIN_FRAME_ID (0x11au)
#define QPUP_AXIS_8_SET_VEL_GAINS_FRAME_ID (0x11bu)
#define QPUP_AXIS_9_HEARTBEAT_FRAME_ID (0x121u)
#define QPUP_AXIS_9_ESTOP_FRAME_ID (0x122u)
#define QPUP_AXIS_9_GET_MOTOR_ERROR_FRAME_ID (0x123u)
#define QPUP_AXIS_9_GET_ENCODER_ERROR_FRAME_ID (0x124u)
#define QPUP_AXIS_9_GET_SENSORLESS_ERROR_FRAME_ID (0x125u)
#define QPUP_AXIS_9_SET_AXIS_NODE_ID_FRAME_ID (0x126u)
#define QPUP_AXIS_9_SET_AXIS_STATE_FRAME_ID (0x127u)
#define QPUP_AXIS_9_GET_ENCODER_ESTIMATES_FRAME_ID (0x129u)
#define QPUP_AXIS_9_GET_ENCODER_COUNT_FRAME_ID (0x12au)
#define QPUP_AXIS_9_SET_CONTROLLER_MODE_FRAME_ID (0x12bu)
#define QPUP_AXIS_9_SET_INPUT_POS_FRAME_ID (0x12cu)
#define QPUP_AXIS_9_SET_INPUT_VEL_FRAME_ID (0x12du)
#define QPUP_AXIS_9_SET_INPUT_TORQUE_FRAME_ID (0x12eu)
#define QPUP_AXIS_9_SET_LIMITS_FRAME_ID (0x12fu)
#define QPUP_AXIS_9_START_ANTICOGGING_FRAME_ID (0x130u)
#define QPUP_AXIS_9_SET_TRAJ_VEL_LIMIT_FRAME_ID (0x131u)
#define QPUP_AXIS_9_SET_TRAJ_ACCEL_LIMITS_FRAME_ID (0x132u)
#define QPUP_AXIS_9_SET_TRAJ_INERTIA_FRAME_ID (0x133u)
#define QPUP_AXIS_9_GET_IQ_FRAME_ID (0x134u)
#define QPUP_AXIS_9_GET_SENSORLESS_ESTIMATES_FRAME_ID (0x135u)
#define QPUP_AXIS_9_REBOOT_FRAME_ID (0x136u)
#define QPUP_AXIS_9_GET_VBUS_VOLTAGE_FRAME_ID (0x137u)
#define QPUP_AXIS_9_CLEAR_ERRORS_FRAME_ID (0x138u)
#define QPUP_AXIS_9_SET_LINEAR_COUNT_FRAME_ID (0x139u)
#define QPUP_AXIS_9_SET_POS_GAIN_FRAME_ID (0x13au)
#define QPUP_AXIS_9_SET_VEL_GAINS_FRAME_ID (0x13bu)
#define QPUP_AXIS_10_HEARTBEAT_FRAME_ID (0x141u)
#define QPUP_AXIS_10_ESTOP_FRAME_ID (0x142u)
#define QPUP_AXIS_10_GET_MOTOR_ERROR_FRAME_ID (0x143u)
#define QPUP_AXIS_10_GET_ENCODER_ERROR_FRAME_ID (0x144u)
#define QPUP_AXIS_10_GET_SENSORLESS_ERROR_FRAME_ID (0x145u)
#define QPUP_AXIS_10_SET_AXIS_NODE_ID_FRAME_ID (0x146u)
#define QPUP_AXIS_10_SET_AXIS_STATE_FRAME_ID (0x147u)
#define QPUP_AXIS_10_GET_ENCODER_ESTIMATES_FRAME_ID (0x149u)
#define QPUP_AXIS_10_GET_ENCODER_COUNT_FRAME_ID (0x14au)
#define QPUP_AXIS_10_SET_CONTROLLER_MODE_FRAME_ID (0x14bu)
#define QPUP_AXIS_10_SET_INPUT_POS_FRAME_ID (0x14cu)
#define QPUP_AXIS_10_SET_INPUT_VEL_FRAME_ID (0x14du)
#define QPUP_AXIS_10_SET_INPUT_TORQUE_FRAME_ID (0x14eu)
#define QPUP_AXIS_10_SET_LIMITS_FRAME_ID (0x14fu)
#define QPUP_AXIS_10_START_ANTICOGGING_FRAME_ID (0x150u)
#define QPUP_AXIS_10_SET_TRAJ_VEL_LIMIT_FRAME_ID (0x151u)
#define QPUP_AXIS_10_SET_TRAJ_ACCEL_LIMITS_FRAME_ID (0x152u)
#define QPUP_AXIS_10_SET_TRAJ_INERTIA_FRAME_ID (0x153u)
#define QPUP_AXIS_10_GET_IQ_FRAME_ID (0x154u)
#define QPUP_AXIS_10_GET_SENSORLESS_ESTIMATES_FRAME_ID (0x155u)
#define QPUP_AXIS_10_REBOOT_FRAME_ID (0x156u)
#define QPUP_AXIS_10_GET_VBUS_VOLTAGE_FRAME_ID (0x157u)
#define QPUP_AXIS_10_CLEAR_ERRORS_FRAME_ID (0x158u)
#define QPUP_AXIS_10_SET_LINEAR_COUNT_FRAME_ID (0x159u)
#define QPUP_AXIS_10_SET_POS_GAIN_FRAME_ID (0x15au)
#define QPUP_AXIS_10_SET_VEL_GAINS_FRAME_ID (0x15bu)
#define QPUP_AXIS_11_HEARTBEAT_FRAME_ID (0x161u)
#define QPUP_AXIS_11_ESTOP_FRAME_ID (0x162u)
#define QPUP_AXIS_11_GET_MOTOR_ERROR_FRAME_ID (0x163u)
#define QPUP_AXIS_11_GET_ENCODER_ERROR_FRAME_ID (0x164u)
#define QPUP_AXIS_11_GET_SENSORLESS_ERROR_FRAME_ID (0x165u)
#define QPUP_AXIS_11_SET_AXIS_NODE_ID_FRAME_ID (0x166u)
#define QPUP_AXIS_11_SET_AXIS_STATE_FRAME_ID (0x167u)
#define QPUP_AXIS_11_GET_ENCODER_ESTIMATES_FRAME_ID (0x169u)
#define QPUP_AXIS_11_GET_ENCODER_COUNT_FRAME_ID (0x16au)
#define QPUP_AXIS_11_SET_CONTROLLER_MODE_FRAME_ID (0x16bu)
#define QPUP_AXIS_11_SET_INPUT_POS_FRAME_ID (0x16cu)
#define QPUP_AXIS_11_SET_INPUT_VEL_FRAME_ID (0x16du)
#define QPUP_AXIS_11_SET_INPUT_TORQUE_FRAME_ID (0x16eu)
#define QPUP_AXIS_11_SET_LIMITS_FRAME_ID (0x16fu)
#define QPUP_AXIS_11_START_ANTICOGGING_FRAME_ID (0x170u)
#define QPUP_AXIS_11_SET_TRAJ_VEL_LIMIT_FRAME_ID (0x171u)
#define QPUP_AXIS_11_SET_TRAJ_ACCEL_LIMITS_FRAME_ID (0x172u)
#define QPUP_AXIS_11_SET_TRAJ_INERTIA_FRAME_ID (0x173u)
#define QPUP_AXIS_11_GET_IQ_FRAME_ID (0x174u)
#define QPUP_AXIS_11_GET_SENSORLESS_ESTIMATES_FRAME_ID (0x175u)
#define QPUP_AXIS_11_REBOOT_FRAME_ID (0x176u)
#define QPUP_AXIS_11_GET_VBUS_VOLTAGE_FRAME_ID (0x177u)
#define QPUP_AXIS_11_CLEAR_ERRORS_FRAME_ID (0x178u)
#define QPUP_AXIS_11_SET_LINEAR_COUNT_FRAME_ID (0x179u)
#define QPUP_AXIS_11_SET_POS_GAIN_FRAME_ID (0x17au)
#define QPUP_AXIS_11_SET_VEL_GAINS_FRAME_ID (0x17bu)
#define QPUP_AXIS_12_HEARTBEAT_FRAME_ID (0x181u)
#define QPUP_AXIS_12_ESTOP_FRAME_ID (0x182u)
#define QPUP_AXIS_12_GET_MOTOR_ERROR_FRAME_ID (0x183u)
#define QPUP_AXIS_12_GET_ENCODER_ERROR_FRAME_ID (0x184u)
#define QPUP_AXIS_12_GET_SENSORLESS_ERROR_FRAME_ID (0x185u)
#define QPUP_AXIS_12_SET_AXIS_NODE_ID_FRAME_ID (0x186u)
#define QPUP_AXIS_12_SET_AXIS_STATE_FRAME_ID (0x187u)
#define QPUP_AXIS_12_GET_ENCODER_ESTIMATES_FRAME_ID (0x189u)
#define QPUP_AXIS_12_GET_ENCODER_COUNT_FRAME_ID (0x18au)
#define QPUP_AXIS_12_SET_CONTROLLER_MODE_FRAME_ID (0x18bu)
#define QPUP_AXIS_12_SET_INPUT_POS_FRAME_ID (0x18cu)
#define QPUP_AXIS_12_SET_INPUT_VEL_FRAME_ID (0x18du)
#define QPUP_AXIS_12_SET_INPUT_TORQUE_FRAME_ID (0x18eu)
#define QPUP_AXIS_12_SET_LIMITS_FRAME_ID (0x18fu)
#define QPUP_AXIS_12_START_ANTICOGGING_FRAME_ID (0x190u)
#define QPUP_AXIS_12_SET_TRAJ_VEL_LIMIT_FRAME_ID (0x191u)
#define QPUP_AXIS_12_SET_TRAJ_ACCEL_LIMITS_FRAME_ID (0x192u)
#define QPUP_AXIS_12_SET_TRAJ_INERTIA_FRAME_ID (0x193u)
#define QPUP_AXIS_12_GET_IQ_FRAME_ID (0x194u)
#define QPUP_AXIS_12_GET_SENSORLESS_ESTIMATES_FRAME_ID (0x195u)
#define QPUP_AXIS_12_REBOOT_FRAME_ID (0x196u)
#define QPUP_AXIS_12_GET_VBUS_VOLTAGE_FRAME_ID (0x197u)
#define QPUP_AXIS_12_CLEAR_ERRORS_FRAME_ID (0x198u)
#define QPUP_AXIS_12_SET_LINEAR_COUNT_FRAME_ID (0x199u)
#define QPUP_AXIS_12_SET_POS_GAIN_FRAME_ID (0x19au)
#define QPUP_AXIS_12_SET_VEL_GAINS_FRAME_ID (0x19bu)

/* Frame lengths in bytes. */
#define QPUP_ODRIVE_HEARTBEAT_LENGTH (8u)
#define QPUP_ODRIVE_ESTOP_LENGTH (0u)
#define QPUP_ODRIVE_GET_MOTOR_ERROR_LENGTH (8u)
#define QPUP_ODRIVE_GET_ENCODER_ERROR_LENGTH (8u)
#define QPUP_ODRIVE_GET_SENSORLESS_ERROR_LENGTH (8u)
#define QPUP_ODRIVE_SET_AXIS_NODE_ID_LENGTH (8u)
#define QPUP_ODRIVE_SET_AXIS_STATE_LENGTH (8u)
#define QPUP_ODRIVE_GET_ENCODER_ESTIMATES_LENGTH (8u)
#define QPUP_ODRIVE_GET_ENCODER_COUNT_LENGTH (8u)
#define QPUP_ODRIVE_SET_CONTROLLER_MODE_LENGTH (8u)
#define QPUP_ODRIVE_SET_INPUT_POS_LENGTH (8u)
#define QPUP_ODRIVE_SET_INPUT_VEL_LENGTH (8u)
#define QPUP_ODRIVE_SET_INPUT_TORQUE_LENGTH (8u)
#define QPUP_ODRIVE_SET_LIMITS_LENGTH (8u)
#define QPUP_ODRIVE_START_ANTICOGGING_LENGTH (0u)
#define QPUP_ODRIVE_SET_TRAJ_VEL_LIMIT_LENGTH (8u)
#define QPUP_ODRIVE_SET_TRAJ_ACCEL_LIMITS_LENGTH (8u)
#define QPUP_ODRIVE_SET_TRAJ_INERTIA_LENGTH (8u)
#define QPUP_ODRIVE_GET_IQ_LENGTH (8u)
#define QPUP_ODRIVE_GET_SENSORLESS_ESTIMATES_LENGTH (8u)
#define QPUP_ODRIVE_REBOOT_LENGTH (0u)
#define QPUP_ODRIVE_GET_VBUS_VOLTAGE_LENGTH (8u)
#define QPUP_ODRIVE_CLEAR_ERRORS_LENGTH (0u)
#define QPUP_ODRIVE_SET_LINEAR_COUNT_LENGTH (8u)
#define QPUP_ODRIVE_SET_POS_GAIN_LENGTH (8u)
#define QPUP_ODRIVE_SET_VEL_GAINS_LENGTH (8u)
#define QPUP_AXIS_1_HEARTBEAT_LENGTH (8u)
#define QPUP_AXIS_1_ESTOP_LENGTH (0u)
#define QPUP_AXIS_1_GET_MOTOR_ERROR_LENGTH (8u)
#define QPUP_AXIS_1_GET_ENCODER_ERROR_LENGTH (8u)
#define QPUP_AXIS_1_GET_SENSORLESS_ERROR_LENGTH (8u)
#define QPUP_AXIS_1_SET_AXIS_NODE_ID_LENGTH (8u)
#define QPUP_AXIS_1_SET_AXIS_STATE_LENGTH (8u)
#define QPUP_AXIS_1_GET_ENCODER_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_1_GET_ENCODER_COUNT_LENGTH (8u)
#define QPUP_AXIS_1_SET_CONTROLLER_MODE_LENGTH (8u)
#define QPUP_AXIS_1_SET_INPUT_POS_LENGTH (8u)
#define QPUP_AXIS_1_SET_INPUT_VEL_LENGTH (8u)
#define QPUP_AXIS_1_SET_INPUT_TORQUE_LENGTH (8u)
#define QPUP_AXIS_1_SET_LIMITS_LENGTH (8u)
#define QPUP_AXIS_1_START_ANTICOGGING_LENGTH (0u)
#define QPUP_AXIS_1_SET_TRAJ_VEL_LIMIT_LENGTH (8u)
#define QPUP_AXIS_1_SET_TRAJ_ACCEL_LIMITS_LENGTH (8u)
#define QPUP_AXIS_1_SET_TRAJ_INERTIA_LENGTH (8u)
#define QPUP_AXIS_1_GET_IQ_LENGTH (8u)
#define QPUP_AXIS_1_GET_SENSORLESS_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_1_REBOOT_LENGTH (0u)
#define QPUP_AXIS_1_GET_VBUS_VOLTAGE_LENGTH (8u)
#define QPUP_AXIS_1_CLEAR_ERRORS_LENGTH (0u)
#define QPUP_AXIS_1_SET_LINEAR_COUNT_LENGTH (8u)
#define QPUP_AXIS_1_SET_POS_GAIN_LENGTH (8u)
#define QPUP_AXIS_1_SET_VEL_GAINS_LENGTH (8u)
#define QPUP_AXIS_2_HEARTBEAT_LENGTH (8u)
#define QPUP_AXIS_2_ESTOP_LENGTH (0u)
#define QPUP_AXIS_2_GET_MOTOR_ERROR_LENGTH (8u)
#define QPUP_AXIS_2_GET_ENCODER_ERROR_LENGTH (8u)
#define QPUP_AXIS_2_GET_SENSORLESS_ERROR_LENGTH (8u)
#define QPUP_AXIS_2_SET_AXIS_NODE_ID_LENGTH (8u)
#define QPUP_AXIS_2_SET_AXIS_STATE_LENGTH (8u)
#define QPUP_AXIS_2_GET_ENCODER_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_2_GET_ENCODER_COUNT_LENGTH (8u)
#define QPUP_AXIS_2_SET_CONTROLLER_MODE_LENGTH (8u)
#define QPUP_AXIS_2_SET_INPUT_POS_LENGTH (8u)
#define QPUP_AXIS_2_SET_INPUT_VEL_LENGTH (8u)
#define QPUP_AXIS_2_SET_INPUT_TORQUE_LENGTH (8u)
#define QPUP_AXIS_2_SET_LIMITS_LENGTH (8u)
#define QPUP_AXIS_2_START_ANTICOGGING_LENGTH (0u)
#define QPUP_AXIS_2_SET_TRAJ_VEL_LIMIT_LENGTH (8u)
#define QPUP_AXIS_2_SET_TRAJ_ACCEL_LIMITS_LENGTH (8u)
#define QPUP_AXIS_2_SET_TRAJ_INERTIA_LENGTH (8u)
#define QPUP_AXIS_2_GET_IQ_LENGTH (8u)
#define QPUP_AXIS_2_GET_SENSORLESS_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_2_REBOOT_LENGTH (0u)
#define QPUP_AXIS_2_GET_VBUS_VOLTAGE_LENGTH (8u)
#define QPUP_AXIS_2_CLEAR_ERRORS_LENGTH (0u)
#define QPUP_AXIS_2_SET_LINEAR_COUNT_LENGTH (8u)
#define QPUP_AXIS_2_SET_POS_GAIN_LENGTH (8u)
#define QPUP_AXIS_2_SET_VEL_GAINS_LENGTH (8u)
#define QPUP_AXIS_3_HEARTBEAT_LENGTH (8u)
#define QPUP_AXIS_3_ESTOP_LENGTH (0u)
#define QPUP_AXIS_3_GET_MOTOR_ERROR_LENGTH (8u)
#define QPUP_AXIS_3_GET_ENCODER_ERROR_LENGTH (8u)
#define QPUP_AXIS_3_GET_SENSORLESS_ERROR_LENGTH (8u)
#define QPUP_AXIS_3_SET_AXIS_NODE_ID_LENGTH (8u)
#define QPUP_AXIS_3_SET_AXIS_STATE_LENGTH (8u)
#define QPUP_AXIS_3_GET_ENCODER_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_3_GET_ENCODER_COUNT_LENGTH (8u)
#define QPUP_AXIS_3_SET_CONTROLLER_MODE_LENGTH (8u)
#define QPUP_AXIS_3_SET_INPUT_POS_LENGTH (8u)
#define QPUP_AXIS_3_SET_INPUT_VEL_LENGTH (8u)
#define QPUP_AXIS_3_SET_INPUT_TORQUE_LENGTH (8u)
#define QPUP_AXIS_3_SET_LIMITS_LENGTH (8u)
#define QPUP_AXIS_3_START_ANTICOGGING_LENGTH (0u)
#define QPUP_AXIS_3_SET_TRAJ_VEL_LIMIT_LENGTH (8u)
#define QPUP_AXIS_3_SET_TRAJ_ACCEL_LIMITS_LENGTH (8u)
#define QPUP_AXIS_3_SET_TRAJ_INERTIA_LENGTH (8u)
#define QPUP_AXIS_3_GET_IQ_LENGTH (8u)
#define QPUP_AXIS_3_GET_SENSORLESS_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_3_REBOOT_LENGTH (0u)
#define QPUP_AXIS_3_GET_VBUS_VOLTAGE_LENGTH (8u)
#define QPUP_AXIS_3_CLEAR_ERRORS_LENGTH (0u)
#define QPUP_AXIS_3_SET_LINEAR_COUNT_LENGTH (8u)
#define QPUP_AXIS_3_SET_POS_GAIN_LENGTH (8u)
#define QPUP_AXIS_3_SET_VEL_GAINS_LENGTH (8u)
#define QPUP_AXIS_4_HEARTBEAT_LENGTH (8u)
#define QPUP_AXIS_4_ESTOP_LENGTH (0u)
#define QPUP_AXIS_4_GET_MOTOR_ERROR_LENGTH (8u)
#define QPUP_AXIS_4_GET_ENCODER_ERROR_LENGTH (8u)
#define QPUP_AXIS_4_GET_SENSORLESS_ERROR_LENGTH (8u)
#define QPUP_AXIS_4_SET_AXIS_NODE_ID_LENGTH (8u)
#define QPUP_AXIS_4_SET_AXIS_STATE_LENGTH (8u)
#define QPUP_AXIS_4_GET_ENCODER_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_4_GET_ENCODER_COUNT_LENGTH (8u)
#define QPUP_AXIS_4_SET_CONTROLLER_MODE_LENGTH (8u)
#define QPUP_AXIS_4_SET_INPUT_POS_LENGTH (8u)
#define QPUP_AXIS_4_SET_INPUT_VEL_LENGTH (8u)
#define QPUP_AXIS_4_SET_INPUT_TORQUE_LENGTH (8u)
#define QPUP_AXIS_4_SET_LIMITS_LENGTH (8u)
#define QPUP_AXIS_4_START_ANTICOGGING_LENGTH (0u)
#define QPUP_AXIS_4_SET_TRAJ_VEL_LIMIT_LENGTH (8u)
#define QPUP_AXIS_4_SET_TRAJ_ACCEL_LIMITS_LENGTH (8u)
#define QPUP_AXIS_4_SET_TRAJ_INERTIA_LENGTH (8u)
#define QPUP_AXIS_4_GET_IQ_LENGTH (8u)
#define QPUP_AXIS_4_GET_SENSORLESS_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_4_REBOOT_LENGTH (0u)
#define QPUP_AXIS_4_GET_VBUS_VOLTAGE_LENGTH (8u)
#define QPUP_AXIS_4_CLEAR_ERRORS_LENGTH (0u)
#define QPUP_AXIS_4_SET_LINEAR_COUNT_LENGTH (8u)
#define QPUP_AXIS_4_SET_POS_GAIN_LENGTH (8u)
#define QPUP_AXIS_4_SET_VEL_GAINS_LENGTH (8u)
#define QPUP_AXIS_5_HEARTBEAT_LENGTH (8u)
#define QPUP_AXIS_5_ESTOP_LENGTH (0u)
#define QPUP_AXIS_5_GET_MOTOR_ERROR_LENGTH (8u)
#define QPUP_AXIS_5_GET_ENCODER_ERROR_LENGTH (8u)
#define QPUP_AXIS_5_GET_SENSORLESS_ERROR_LENGTH (8u)
#define QPUP_AXIS_5_SET_AXIS_NODE_ID_LENGTH (8u)
#define QPUP_AXIS_5_SET_AXIS_STATE_LENGTH (8u)
#define QPUP_AXIS_5_GET_ENCODER_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_5_GET_ENCODER_COUNT_LENGTH (8u)
#define QPUP_AXIS_5_SET_CONTROLLER_MODE_LENGTH (8u)
#define QPUP_AXIS_5_SET_INPUT_POS_LENGTH (8u)
#define QPUP_AXIS_5_SET_INPUT_VEL_LENGTH (8u)
#define QPUP_AXIS_5_SET_INPUT_TORQUE_LENGTH (8u)
#define QPUP_AXIS_5_SET_LIMITS_LENGTH (8u)
#define QPUP_AXIS_5_START_ANTICOGGING_LENGTH (0u)
#define QPUP_AXIS_5_SET_TRAJ_VEL_LIMIT_LENGTH (8u)
#define QPUP_AXIS_5_SET_TRAJ_ACCEL_LIMITS_LENGTH (8u)
#define QPUP_AXIS_5_SET_TRAJ_INERTIA_LENGTH (8u)
#define QPUP_AXIS_5_GET_IQ_LENGTH (8u)
#define QPUP_AXIS_5_GET_SENSORLESS_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_5_REBOOT_LENGTH (0u)
#define QPUP_AXIS_5_GET_VBUS_VOLTAGE_LENGTH (8u)
#define QPUP_AXIS_5_CLEAR_ERRORS_LENGTH (0u)
#define QPUP_AXIS_5_SET_LINEAR_COUNT_LENGTH (8u)
#define QPUP_AXIS_5_SET_POS_GAIN_LENGTH (8u)
#define QPUP_AXIS_5_SET_VEL_GAINS_LENGTH (8u)
#define QPUP_AXIS_6_HEARTBEAT_LENGTH (8u)
#define QPUP_AXIS_6_ESTOP_LENGTH (0u)
#define QPUP_AXIS_6_GET_MOTOR_ERROR_LENGTH (8u)
#define QPUP_AXIS_6_GET_ENCODER_ERROR_LENGTH (8u)
#define QPUP_AXIS_6_GET_SENSORLESS_ERROR_LENGTH (8u)
#define QPUP_AXIS_6_SET_AXIS_NODE_ID_LENGTH (8u)
#define QPUP_AXIS_6_SET_AXIS_STATE_LENGTH (8u)
#define QPUP_AXIS_6_GET_ENCODER_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_6_GET_ENCODER_COUNT_LENGTH (8u)
#define QPUP_AXIS_6_SET_CONTROLLER_MODE_LENGTH (8u)
#define QPUP_AXIS_6_SET_INPUT_POS_LENGTH (8u)
#define QPUP_AXIS_6_SET_INPUT_VEL_LENGTH (8u)
#define QPUP_AXIS_6_SET_INPUT_TORQUE_LENGTH (8u)
#define QPUP_AXIS_6_SET_LIMITS_LENGTH (8u)
#define QPUP_AXIS_6_START_ANTICOGGING_LENGTH (0u)
#define QPUP_AXIS_6_SET_TRAJ_VEL_LIMIT_LENGTH (8u)
#define QPUP_AXIS_6_SET_TRAJ_ACCEL_LIMITS_LENGTH (8u)
#define QPUP_AXIS_6_SET_TRAJ_INERTIA_LENGTH (8u)
#define QPUP_AXIS_6_GET_IQ_LENGTH (8u)
#define QPUP_AXIS_6_GET_SENSORLESS_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_6_REBOOT_LENGTH (0u)
#define QPUP_AXIS_6_GET_VBUS_VOLTAGE_LENGTH (8u)
#define QPUP_AXIS_6_CLEAR_ERRORS_LENGTH (0u)
#define QPUP_AXIS_6_SET_LINEAR_COUNT_LENGTH (8u)
#define QPUP_AXIS_6_SET_POS_GAIN_LENGTH (8u)
#define QPUP_AXIS_6_SET_VEL_GAINS_LENGTH (8u)
#define QPUP_AXIS_7_HEARTBEAT_LENGTH (8u)
#define QPUP_AXIS_7_ESTOP_LENGTH (0u)
#define QPUP_AXIS_7_GET_MOTOR_ERROR_LENGTH (8u)
#define QPUP_AXIS_7_GET_ENCODER_ERROR_LENGTH (8u)
#define QPUP_AXIS_7_GET_SENSORLESS_ERROR_LENGTH (8u)
#define QPUP_AXIS_7_SET_AXIS_NODE_ID_LENGTH (8u)
#define QPUP_AXIS_7_SET_AXIS_STATE_LENGTH (8u)
#define QPUP_AXIS_7_GET_ENCODER_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_7_GET_ENCODER_COUNT_LENGTH (8u)
#define QPUP_AXIS_7_SET_CONTROLLER_MODE_LENGTH (8u)
#define QPUP_AXIS_7_SET_INPUT_POS_LENGTH (8u)
#define QPUP_AXIS_7_SET_INPUT_VEL_LENGTH (8u)
#define QPUP_AXIS_7_SET_INPUT_TORQUE_LENGTH (8u)
#define QPUP_AXIS_7_SET_LIMITS_LENGTH (8u)
#define QPUP_AXIS_7_START_ANTICOGGING_LENGTH (0u)
#define QPUP_AXIS_7_SET_TRAJ_VEL_LIMIT_LENGTH (8u)
#define QPUP_AXIS_7_SET_TRAJ_ACCEL_LIMITS_LENGTH (8u)
#define QPUP_AXIS_7_SET_TRAJ_INERTIA_LENGTH (8u)
#define QPUP_AXIS_7_GET_IQ_LENGTH (8u)
#define QPUP_AXIS_7_GET_SENSORLESS_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_7_REBOOT_LENGTH (0u)
#define QPUP_AXIS_7_GET_VBUS_VOLTAGE_LENGTH (8u)
#define QPUP_AXIS_7_CLEAR_ERRORS_LENGTH (0u)
#define QPUP_AXIS_7_SET_LINEAR_COUNT_LENGTH (8u)
#define QPUP_AXIS_7_SET_POS_GAIN_LENGTH (8u)
#define QPUP_AXIS_7_SET_VEL_GAINS_LENGTH (8u)
#define QPUP_AXIS_8_HEARTBEAT_LENGTH (8u)
#define QPUP_AXIS_8_ESTOP_LENGTH (0u)
#define QPUP_AXIS_8_GET_MOTOR_ERROR_LENGTH (8u)
#define QPUP_AXIS_8_GET_ENCODER_ERROR_LENGTH (8u)
#define QPUP_AXIS_8_GET_SENSORLESS_ERROR_LENGTH (8u)
#define QPUP_AXIS_8_SET_AXIS_NODE_ID_LENGTH (8u)
#define QPUP_AXIS_8_SET_AXIS_STATE_LENGTH (8u)
#define QPUP_AXIS_8_GET_ENCODER_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_8_GET_ENCODER_COUNT_LENGTH (8u)
#define QPUP_AXIS_8_SET_CONTROLLER_MODE_LENGTH (8u)
#define QPUP_AXIS_8_SET_INPUT_POS_LENGTH (8u)
#define QPUP_AXIS_8_SET_INPUT_VEL_LENGTH (8u)
#define QPUP_AXIS_8_SET_INPUT_TORQUE_LENGTH (8u)
#define QPUP_AXIS_8_SET_LIMITS_LENGTH (8u)
#define QPUP_AXIS_8_START_ANTICOGGING_LENGTH (0u)
#define QPUP_AXIS_8_SET_TRAJ_VEL_LIMIT_LENGTH (8u)
#define QPUP_AXIS_8_SET_TRAJ_ACCEL_LIMITS_LENGTH (8u)
#define QPUP_AXIS_8_SET_TRAJ_INERTIA_LENGTH (8u)
#define QPUP_AXIS_8_GET_IQ_LENGTH (8u)
#define QPUP_AXIS_8_GET_SENSORLESS_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_8_REBOOT_LENGTH (0u)
#define QPUP_AXIS_8_GET_VBUS_VOLTAGE_LENGTH (8u)
#define QPUP_AXIS_8_CLEAR_ERRORS_LENGTH (0u)
#define QPUP_AXIS_8_SET_LINEAR_COUNT_LENGTH (8u)
#define QPUP_AXIS_8_SET_POS_GAIN_LENGTH (8u)
#define QPUP_AXIS_8_SET_VEL_GAINS_LENGTH (8u)
#define QPUP_AXIS_9_HEARTBEAT_LENGTH (8u)
#define QPUP_AXIS_9_ESTOP_LENGTH (0u)
#define QPUP_AXIS_9_GET_MOTOR_ERROR_LENGTH (8u)
#define QPUP_AXIS_9_GET_ENCODER_ERROR_LENGTH (8u)
#define QPUP_AXIS_9_GET_SENSORLESS_ERROR_LENGTH (8u)
#define QPUP_AXIS_9_SET_AXIS_NODE_ID_LENGTH (8u)
#define QPUP_AXIS_9_SET_AXIS_STATE_LENGTH (8u)
#define QPUP_AXIS_9_GET_ENCODER_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_9_GET_ENCODER_COUNT_LENGTH (8u)
#define QPUP_AXIS_9_SET_CONTROLLER_MODE_LENGTH (8u)
#define QPUP_AXIS_9_SET_INPUT_POS_LENGTH (8u)
#define QPUP_AXIS_9_SET_INPUT_VEL_LENGTH (8u)
#define QPUP_AXIS_9_SET_INPUT_TORQUE_LENGTH (8u)
#define QPUP_AXIS_9_SET_LIMITS_LENGTH (8u)
#define QPUP_AXIS_9_START_ANTICOGGING_LENGTH (0u)
#define QPUP_AXIS_9_SET_TRAJ_VEL_LIMIT_LENGTH (8u)
#define QPUP_AXIS_9_SET_TRAJ_ACCEL_LIMITS_LENGTH (8u)
#define QPUP_AXIS_9_SET_TRAJ_INERTIA_LENGTH (8u)
#define QPUP_AXIS_9_GET_IQ_LENGTH (8u)
#define QPUP_AXIS_9_GET_SENSORLESS_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_9_REBOOT_LENGTH (0u)
#define QPUP_AXIS_9_GET_VBUS_VOLTAGE_LENGTH (8u)
#define QPUP_AXIS_9_CLEAR_ERRORS_LENGTH (0u)
#define QPUP_AXIS_9_SET_LINEAR_COUNT_LENGTH (8u)
#define QPUP_AXIS_9_SET_POS_GAIN_LENGTH (8u)
#define QPUP_AXIS_9_SET_VEL_GAINS_LENGTH (8u)
#define QPUP_AXIS_10_HEARTBEAT_LENGTH (8u)
#define QPUP_AXIS_10_ESTOP_LENGTH (0u)
#define QPUP_AXIS_10_GET_MOTOR_ERROR_LENGTH (8u)
#define QPUP_AXIS_10_GET_ENCODER_ERROR_LENGTH (8u)
#define QPUP_AXIS_10_GET_SENSORLESS_ERROR_LENGTH (8u)
#define QPUP_AXIS_10_SET_AXIS_NODE_ID_LENGTH (8u)
#define QPUP_AXIS_10_SET_AXIS_STATE_LENGTH (8u)
#define QPUP_AXIS_10_GET_ENCODER_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_10_GET_ENCODER_COUNT_LENGTH (8u)
#define QPUP_AXIS_10_SET_CONTROLLER_MODE_LENGTH (8u)
#define QPUP_AXIS_10_SET_INPUT_POS_LENGTH (8u)
#define QPUP_AXIS_10_SET_INPUT_VEL_LENGTH (8u)
#define QPUP_AXIS_10_SET_INPUT_TORQUE_LENGTH (8u)
#define QPUP_AXIS_10_SET_LIMITS_LENGTH (8u)
#define QPUP_AXIS_10_START_ANTICOGGING_LENGTH (0u)
#define QPUP_AXIS_10_SET_TRAJ_VEL_LIMIT_LENGTH (8u)
#define QPUP_AXIS_10_SET_TRAJ_ACCEL_LIMITS_LENGTH (8u)
#define QPUP_AXIS_10_SET_TRAJ_INERTIA_LENGTH (8u)
#define QPUP_AXIS_10_GET_IQ_LENGTH (8u)
#define QPUP_AXIS_10_GET_SENSORLESS_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_10_REBOOT_LENGTH (0u)
#define QPUP_AXIS_10_GET_VBUS_VOLTAGE_LENGTH (8u)
#define QPUP_AXIS_10_CLEAR_ERRORS_LENGTH (0u)
#define QPUP_AXIS_10_SET_LINEAR_COUNT_LENGTH (8u)
#define QPUP_AXIS_10_SET_POS_GAIN_LENGTH (8u)
#define QPUP_AXIS_10_SET_VEL_GAINS_LENGTH (8u)
#define QPUP_AXIS_11_HEARTBEAT_LENGTH (8u)
#define QPUP_AXIS_11_ESTOP_LENGTH (0u)
#define QPUP_AXIS_11_GET_MOTOR_ERROR_LENGTH (8u)
#define QPUP_AXIS_11_GET_ENCODER_ERROR_LENGTH (8u)
#define QPUP_AXIS_11_GET_SENSORLESS_ERROR_LENGTH (8u)
#define QPUP_AXIS_11_SET_AXIS_NODE_ID_LENGTH (8u)
#define QPUP_AXIS_11_SET_AXIS_STATE_LENGTH (8u)
#define QPUP_AXIS_11_GET_ENCODER_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_11_GET_ENCODER_COUNT_LENGTH (8u)
#define QPUP_AXIS_11_SET_CONTROLLER_MODE_LENGTH (8u)
#define QPUP_AXIS_11_SET_INPUT_POS_LENGTH (8u)
#define QPUP_AXIS_11_SET_INPUT_VEL_LENGTH (8u)
#define QPUP_AXIS_11_SET_INPUT_TORQUE_LENGTH (8u)
#define QPUP_AXIS_11_SET_LIMITS_LENGTH (8u)
#define QPUP_AXIS_11_START_ANTICOGGING_LENGTH (0u)
#define QPUP_AXIS_11_SET_TRAJ_VEL_LIMIT_LENGTH (8u)
#define QPUP_AXIS_11_SET_TRAJ_ACCEL_LIMITS_LENGTH (8u)
#define QPUP_AXIS_11_SET_TRAJ_INERTIA_LENGTH (8u)
#define QPUP_AXIS_11_GET_IQ_LENGTH (8u)
#define QPUP_AXIS_11_GET_SENSORLESS_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_11_REBOOT_LENGTH (0u)
#define QPUP_AXIS_11_GET_VBUS_VOLTAGE_LENGTH (8u)
#define QPUP_AXIS_11_CLEAR_ERRORS_LENGTH (0u)
#define QPUP_AXIS_11_SET_LINEAR_COUNT_LENGTH (8u)
#define QPUP_AXIS_11_SET_POS_GAIN_LENGTH (8u)
#define QPUP_AXIS_11_SET_VEL_GAINS_LENGTH (8u)
#define QPUP_AXIS_12_HEARTBEAT_LENGTH (8u)
#define QPUP_AXIS_12_ESTOP_LENGTH (0u)
#define QPUP_AXIS_12_GET_MOTOR_ERROR_LENGTH (8u)
#define QPUP_AXIS_12_GET_ENCODER_ERROR_LENGTH (8u)
#define QPUP_AXIS_12_GET_SENSORLESS_ERROR_LENGTH (8u)
#define QPUP_AXIS_12_SET_AXIS_NODE_ID_LENGTH (8u)
#define QPUP_AXIS_12_SET_AXIS_STATE_LENGTH (8u)
#define QPUP_AXIS_12_GET_ENCODER_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_12_GET_ENCODER_COUNT_LENGTH (8u)
#define QPUP_AXIS_12_SET_CONTROLLER_MODE_LENGTH (8u)
#define QPUP_AXIS_12_SET_INPUT_POS_LENGTH (8u)
#define QPUP_AXIS_12_SET_INPUT_VEL_LENGTH (8u)
#define QPUP_AXIS_12_SET_INPUT_TORQUE_LENGTH (8u)
#define QPUP_AXIS_12_SET_LIMITS_LENGTH (8u)
#define QPUP_AXIS_12_START_ANTICOGGING_LENGTH (0u)
#define QPUP_AXIS_12_SET_TRAJ_VEL_LIMIT_LENGTH (8u)
#define QPUP_AXIS_12_SET_TRAJ_ACCEL_LIMITS_LENGTH (8u)
#define QPUP_AXIS_12_SET_TRAJ_INERTIA_LENGTH (8u)
#define QPUP_AXIS_12_GET_IQ_LENGTH (8u)
#define QPUP_AXIS_12_GET_SENSORLESS_ESTIMATES_LENGTH (8u)
#define QPUP_AXIS_12_REBOOT_LENGTH (0u)
#define QPUP_AXIS_12_GET_VBUS_VOLTAGE_LENGTH (8u)
#define QPUP_AXIS_12_CLEAR_ERRORS_LENGTH (0u)
#define QPUP_AXIS_12_SET_LINEAR_COUNT_LENGTH (8u)
#define QPUP_AXIS_12_SET_POS_GAIN_LENGTH (8u)
#define QPUP_AXIS_12_SET_VEL_GAINS_LENGTH (8u)

/* Extended or standard frame types. */
#define QPUP_ODRIVE_HEARTBEAT_IS_EXTENDED (0)
#define QPUP_ODRIVE_ESTOP_IS_EXTENDED (0)
#define QPUP_ODRIVE_GET_MOTOR_ERROR_IS_EXTENDED (0)
#define QPUP_ODRIVE_GET_ENCODER_ERROR_IS_EXTENDED (0)
#define QPUP_ODRIVE_GET_SENSORLESS_ERROR_IS_EXTENDED (0)
#define QPUP_ODRIVE_SET_AXIS_NODE_ID_IS_EXTENDED (0)
#define QPUP_ODRIVE_SET_AXIS_STATE_IS_EXTENDED (0)
#define QPUP_ODRIVE_GET_ENCODER_ESTIMATES_IS_EXTENDED (0)
#define QPUP_ODRIVE_GET_ENCODER_COUNT_IS_EXTENDED (0)
#define QPUP_ODRIVE_SET_CONTROLLER_MODE_IS_EXTENDED (0)
#define QPUP_ODRIVE_SET_INPUT_POS_IS_EXTENDED (0)
#define QPUP_ODRIVE_SET_INPUT_VEL_IS_EXTENDED (0)
#define QPUP_ODRIVE_SET_INPUT_TORQUE_IS_EXTENDED (0)
#define QPUP_ODRIVE_SET_LIMITS_IS_EXTENDED (0)
#define QPUP_ODRIVE_START_ANTICOGGING_IS_EXTENDED (0)
#define QPUP_ODRIVE_SET_TRAJ_VEL_LIMIT_IS_EXTENDED (0)
#define QPUP_ODRIVE_SET_TRAJ_ACCEL_LIMITS_IS_EXTENDED (0)
#define QPUP_ODRIVE_SET_TRAJ_INERTIA_IS_EXTENDED (0)
#define QPUP_ODRIVE_GET_IQ_IS_EXTENDED (0)
#define QPUP_ODRIVE_GET_SENSORLESS_ESTIMATES_IS_EXTENDED (0)
#define QPUP_ODRIVE_REBOOT_IS_EXTENDED (0)
#define QPUP_ODRIVE_GET_VBUS_VOLTAGE_IS_EXTENDED (0)
#define QPUP_ODRIVE_CLEAR_ERRORS_IS_EXTENDED (0)
#define QPUP_ODRIVE_SET_LINEAR_COUNT_IS_EXTENDED (0)
#define QPUP_ODRIVE_SET_POS_GAIN_IS_EXTENDED (0)
#define QPUP_ODRIVE_SET_VEL_GAINS_IS_EXTENDED (0)
#define QPUP_AXIS_1_HEARTBEAT_IS_EXTENDED (0)
#define QPUP_AXIS_1_ESTOP_IS_EXTENDED (0)
#define QPUP_AXIS_1_GET_MOTOR_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_1_GET_ENCODER_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_1_GET_SENSORLESS_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_1_SET_AXIS_NODE_ID_IS_EXTENDED (0)
#define QPUP_AXIS_1_SET_AXIS_STATE_IS_EXTENDED (0)
#define QPUP_AXIS_1_GET_ENCODER_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_1_GET_ENCODER_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_1_SET_CONTROLLER_MODE_IS_EXTENDED (0)
#define QPUP_AXIS_1_SET_INPUT_POS_IS_EXTENDED (0)
#define QPUP_AXIS_1_SET_INPUT_VEL_IS_EXTENDED (0)
#define QPUP_AXIS_1_SET_INPUT_TORQUE_IS_EXTENDED (0)
#define QPUP_AXIS_1_SET_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_1_START_ANTICOGGING_IS_EXTENDED (0)
#define QPUP_AXIS_1_SET_TRAJ_VEL_LIMIT_IS_EXTENDED (0)
#define QPUP_AXIS_1_SET_TRAJ_ACCEL_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_1_SET_TRAJ_INERTIA_IS_EXTENDED (0)
#define QPUP_AXIS_1_GET_IQ_IS_EXTENDED (0)
#define QPUP_AXIS_1_GET_SENSORLESS_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_1_REBOOT_IS_EXTENDED (0)
#define QPUP_AXIS_1_GET_VBUS_VOLTAGE_IS_EXTENDED (0)
#define QPUP_AXIS_1_CLEAR_ERRORS_IS_EXTENDED (0)
#define QPUP_AXIS_1_SET_LINEAR_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_1_SET_POS_GAIN_IS_EXTENDED (0)
#define QPUP_AXIS_1_SET_VEL_GAINS_IS_EXTENDED (0)
#define QPUP_AXIS_2_HEARTBEAT_IS_EXTENDED (0)
#define QPUP_AXIS_2_ESTOP_IS_EXTENDED (0)
#define QPUP_AXIS_2_GET_MOTOR_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_2_GET_ENCODER_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_2_GET_SENSORLESS_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_2_SET_AXIS_NODE_ID_IS_EXTENDED (0)
#define QPUP_AXIS_2_SET_AXIS_STATE_IS_EXTENDED (0)
#define QPUP_AXIS_2_GET_ENCODER_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_2_GET_ENCODER_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_2_SET_CONTROLLER_MODE_IS_EXTENDED (0)
#define QPUP_AXIS_2_SET_INPUT_POS_IS_EXTENDED (0)
#define QPUP_AXIS_2_SET_INPUT_VEL_IS_EXTENDED (0)
#define QPUP_AXIS_2_SET_INPUT_TORQUE_IS_EXTENDED (0)
#define QPUP_AXIS_2_SET_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_2_START_ANTICOGGING_IS_EXTENDED (0)
#define QPUP_AXIS_2_SET_TRAJ_VEL_LIMIT_IS_EXTENDED (0)
#define QPUP_AXIS_2_SET_TRAJ_ACCEL_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_2_SET_TRAJ_INERTIA_IS_EXTENDED (0)
#define QPUP_AXIS_2_GET_IQ_IS_EXTENDED (0)
#define QPUP_AXIS_2_GET_SENSORLESS_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_2_REBOOT_IS_EXTENDED (0)
#define QPUP_AXIS_2_GET_VBUS_VOLTAGE_IS_EXTENDED (0)
#define QPUP_AXIS_2_CLEAR_ERRORS_IS_EXTENDED (0)
#define QPUP_AXIS_2_SET_LINEAR_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_2_SET_POS_GAIN_IS_EXTENDED (0)
#define QPUP_AXIS_2_SET_VEL_GAINS_IS_EXTENDED (0)
#define QPUP_AXIS_3_HEARTBEAT_IS_EXTENDED (0)
#define QPUP_AXIS_3_ESTOP_IS_EXTENDED (0)
#define QPUP_AXIS_3_GET_MOTOR_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_3_GET_ENCODER_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_3_GET_SENSORLESS_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_3_SET_AXIS_NODE_ID_IS_EXTENDED (0)
#define QPUP_AXIS_3_SET_AXIS_STATE_IS_EXTENDED (0)
#define QPUP_AXIS_3_GET_ENCODER_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_3_GET_ENCODER_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_3_SET_CONTROLLER_MODE_IS_EXTENDED (0)
#define QPUP_AXIS_3_SET_INPUT_POS_IS_EXTENDED (0)
#define QPUP_AXIS_3_SET_INPUT_VEL_IS_EXTENDED (0)
#define QPUP_AXIS_3_SET_INPUT_TORQUE_IS_EXTENDED (0)
#define QPUP_AXIS_3_SET_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_3_START_ANTICOGGING_IS_EXTENDED (0)
#define QPUP_AXIS_3_SET_TRAJ_VEL_LIMIT_IS_EXTENDED (0)
#define QPUP_AXIS_3_SET_TRAJ_ACCEL_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_3_SET_TRAJ_INERTIA_IS_EXTENDED (0)
#define QPUP_AXIS_3_GET_IQ_IS_EXTENDED (0)
#define QPUP_AXIS_3_GET_SENSORLESS_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_3_REBOOT_IS_EXTENDED (0)
#define QPUP_AXIS_3_GET_VBUS_VOLTAGE_IS_EXTENDED (0)
#define QPUP_AXIS_3_CLEAR_ERRORS_IS_EXTENDED (0)
#define QPUP_AXIS_3_SET_LINEAR_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_3_SET_POS_GAIN_IS_EXTENDED (0)
#define QPUP_AXIS_3_SET_VEL_GAINS_IS_EXTENDED (0)
#define QPUP_AXIS_4_HEARTBEAT_IS_EXTENDED (0)
#define QPUP_AXIS_4_ESTOP_IS_EXTENDED (0)
#define QPUP_AXIS_4_GET_MOTOR_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_4_GET_ENCODER_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_4_GET_SENSORLESS_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_4_SET_AXIS_NODE_ID_IS_EXTENDED (0)
#define QPUP_AXIS_4_SET_AXIS_STATE_IS_EXTENDED (0)
#define QPUP_AXIS_4_GET_ENCODER_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_4_GET_ENCODER_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_4_SET_CONTROLLER_MODE_IS_EXTENDED (0)
#define QPUP_AXIS_4_SET_INPUT_POS_IS_EXTENDED (0)
#define QPUP_AXIS_4_SET_INPUT_VEL_IS_EXTENDED (0)
#define QPUP_AXIS_4_SET_INPUT_TORQUE_IS_EXTENDED (0)
#define QPUP_AXIS_4_SET_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_4_START_ANTICOGGING_IS_EXTENDED (0)
#define QPUP_AXIS_4_SET_TRAJ_VEL_LIMIT_IS_EXTENDED (0)
#define QPUP_AXIS_4_SET_TRAJ_ACCEL_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_4_SET_TRAJ_INERTIA_IS_EXTENDED (0)
#define QPUP_AXIS_4_GET_IQ_IS_EXTENDED (0)
#define QPUP_AXIS_4_GET_SENSORLESS_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_4_REBOOT_IS_EXTENDED (0)
#define QPUP_AXIS_4_GET_VBUS_VOLTAGE_IS_EXTENDED (0)
#define QPUP_AXIS_4_CLEAR_ERRORS_IS_EXTENDED (0)
#define QPUP_AXIS_4_SET_LINEAR_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_4_SET_POS_GAIN_IS_EXTENDED (0)
#define QPUP_AXIS_4_SET_VEL_GAINS_IS_EXTENDED (0)
#define QPUP_AXIS_5_HEARTBEAT_IS_EXTENDED (0)
#define QPUP_AXIS_5_ESTOP_IS_EXTENDED (0)
#define QPUP_AXIS_5_GET_MOTOR_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_5_GET_ENCODER_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_5_GET_SENSORLESS_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_5_SET_AXIS_NODE_ID_IS_EXTENDED (0)
#define QPUP_AXIS_5_SET_AXIS_STATE_IS_EXTENDED (0)
#define QPUP_AXIS_5_GET_ENCODER_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_5_GET_ENCODER_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_5_SET_CONTROLLER_MODE_IS_EXTENDED (0)
#define QPUP_AXIS_5_SET_INPUT_POS_IS_EXTENDED (0)
#define QPUP_AXIS_5_SET_INPUT_VEL_IS_EXTENDED (0)
#define QPUP_AXIS_5_SET_INPUT_TORQUE_IS_EXTENDED (0)
#define QPUP_AXIS_5_SET_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_5_START_ANTICOGGING_IS_EXTENDED (0)
#define QPUP_AXIS_5_SET_TRAJ_VEL_LIMIT_IS_EXTENDED (0)
#define QPUP_AXIS_5_SET_TRAJ_ACCEL_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_5_SET_TRAJ_INERTIA_IS_EXTENDED (0)
#define QPUP_AXIS_5_GET_IQ_IS_EXTENDED (0)
#define QPUP_AXIS_5_GET_SENSORLESS_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_5_REBOOT_IS_EXTENDED (0)
#define QPUP_AXIS_5_GET_VBUS_VOLTAGE_IS_EXTENDED (0)
#define QPUP_AXIS_5_CLEAR_ERRORS_IS_EXTENDED (0)
#define QPUP_AXIS_5_SET_LINEAR_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_5_SET_POS_GAIN_IS_EXTENDED (0)
#define QPUP_AXIS_5_SET_VEL_GAINS_IS_EXTENDED (0)
#define QPUP_AXIS_6_HEARTBEAT_IS_EXTENDED (0)
#define QPUP_AXIS_6_ESTOP_IS_EXTENDED (0)
#define QPUP_AXIS_6_GET_MOTOR_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_6_GET_ENCODER_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_6_GET_SENSORLESS_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_6_SET_AXIS_NODE_ID_IS_EXTENDED (0)
#define QPUP_AXIS_6_SET_AXIS_STATE_IS_EXTENDED (0)
#define QPUP_AXIS_6_GET_ENCODER_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_6_GET_ENCODER_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_6_SET_CONTROLLER_MODE_IS_EXTENDED (0)
#define QPUP_AXIS_6_SET_INPUT_POS_IS_EXTENDED (0)
#define QPUP_AXIS_6_SET_INPUT_VEL_IS_EXTENDED (0)
#define QPUP_AXIS_6_SET_INPUT_TORQUE_IS_EXTENDED (0)
#define QPUP_AXIS_6_SET_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_6_START_ANTICOGGING_IS_EXTENDED (0)
#define QPUP_AXIS_6_SET_TRAJ_VEL_LIMIT_IS_EXTENDED (0)
#define QPUP_AXIS_6_SET_TRAJ_ACCEL_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_6_SET_TRAJ_INERTIA_IS_EXTENDED (0)
#define QPUP_AXIS_6_GET_IQ_IS_EXTENDED (0)
#define QPUP_AXIS_6_GET_SENSORLESS_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_6_REBOOT_IS_EXTENDED (0)
#define QPUP_AXIS_6_GET_VBUS_VOLTAGE_IS_EXTENDED (0)
#define QPUP_AXIS_6_CLEAR_ERRORS_IS_EXTENDED (0)
#define QPUP_AXIS_6_SET_LINEAR_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_6_SET_POS_GAIN_IS_EXTENDED (0)
#define QPUP_AXIS_6_SET_VEL_GAINS_IS_EXTENDED (0)
#define QPUP_AXIS_7_HEARTBEAT_IS_EXTENDED (0)
#define QPUP_AXIS_7_ESTOP_IS_EXTENDED (0)
#define QPUP_AXIS_7_GET_MOTOR_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_7_GET_ENCODER_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_7_GET_SENSORLESS_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_7_SET_AXIS_NODE_ID_IS_EXTENDED (0)
#define QPUP_AXIS_7_SET_AXIS_STATE_IS_EXTENDED (0)
#define QPUP_AXIS_7_GET_ENCODER_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_7_GET_ENCODER_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_7_SET_CONTROLLER_MODE_IS_EXTENDED (0)
#define QPUP_AXIS_7_SET_INPUT_POS_IS_EXTENDED (0)
#define QPUP_AXIS_7_SET_INPUT_VEL_IS_EXTENDED (0)
#define QPUP_AXIS_7_SET_INPUT_TORQUE_IS_EXTENDED (0)
#define QPUP_AXIS_7_SET_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_7_START_ANTICOGGING_IS_EXTENDED (0)
#define QPUP_AXIS_7_SET_TRAJ_VEL_LIMIT_IS_EXTENDED (0)
#define QPUP_AXIS_7_SET_TRAJ_ACCEL_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_7_SET_TRAJ_INERTIA_IS_EXTENDED (0)
#define QPUP_AXIS_7_GET_IQ_IS_EXTENDED (0)
#define QPUP_AXIS_7_GET_SENSORLESS_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_7_REBOOT_IS_EXTENDED (0)
#define QPUP_AXIS_7_GET_VBUS_VOLTAGE_IS_EXTENDED (0)
#define QPUP_AXIS_7_CLEAR_ERRORS_IS_EXTENDED (0)
#define QPUP_AXIS_7_SET_LINEAR_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_7_SET_POS_GAIN_IS_EXTENDED (0)
#define QPUP_AXIS_7_SET_VEL_GAINS_IS_EXTENDED (0)
#define QPUP_AXIS_8_HEARTBEAT_IS_EXTENDED (0)
#define QPUP_AXIS_8_ESTOP_IS_EXTENDED (0)
#define QPUP_AXIS_8_GET_MOTOR_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_8_GET_ENCODER_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_8_GET_SENSORLESS_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_8_SET_AXIS_NODE_ID_IS_EXTENDED (0)
#define QPUP_AXIS_8_SET_AXIS_STATE_IS_EXTENDED (0)
#define QPUP_AXIS_8_GET_ENCODER_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_8_GET_ENCODER_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_8_SET_CONTROLLER_MODE_IS_EXTENDED (0)
#define QPUP_AXIS_8_SET_INPUT_POS_IS_EXTENDED (0)
#define QPUP_AXIS_8_SET_INPUT_VEL_IS_EXTENDED (0)
#define QPUP_AXIS_8_SET_INPUT_TORQUE_IS_EXTENDED (0)
#define QPUP_AXIS_8_SET_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_8_START_ANTICOGGING_IS_EXTENDED (0)
#define QPUP_AXIS_8_SET_TRAJ_VEL_LIMIT_IS_EXTENDED (0)
#define QPUP_AXIS_8_SET_TRAJ_ACCEL_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_8_SET_TRAJ_INERTIA_IS_EXTENDED (0)
#define QPUP_AXIS_8_GET_IQ_IS_EXTENDED (0)
#define QPUP_AXIS_8_GET_SENSORLESS_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_8_REBOOT_IS_EXTENDED (0)
#define QPUP_AXIS_8_GET_VBUS_VOLTAGE_IS_EXTENDED (0)
#define QPUP_AXIS_8_CLEAR_ERRORS_IS_EXTENDED (0)
#define QPUP_AXIS_8_SET_LINEAR_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_8_SET_POS_GAIN_IS_EXTENDED (0)
#define QPUP_AXIS_8_SET_VEL_GAINS_IS_EXTENDED (0)
#define QPUP_AXIS_9_HEARTBEAT_IS_EXTENDED (0)
#define QPUP_AXIS_9_ESTOP_IS_EXTENDED (0)
#define QPUP_AXIS_9_GET_MOTOR_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_9_GET_ENCODER_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_9_GET_SENSORLESS_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_9_SET_AXIS_NODE_ID_IS_EXTENDED (0)
#define QPUP_AXIS_9_SET_AXIS_STATE_IS_EXTENDED (0)
#define QPUP_AXIS_9_GET_ENCODER_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_9_GET_ENCODER_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_9_SET_CONTROLLER_MODE_IS_EXTENDED (0)
#define QPUP_AXIS_9_SET_INPUT_POS_IS_EXTENDED (0)
#define QPUP_AXIS_9_SET_INPUT_VEL_IS_EXTENDED (0)
#define QPUP_AXIS_9_SET_INPUT_TORQUE_IS_EXTENDED (0)
#define QPUP_AXIS_9_SET_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_9_START_ANTICOGGING_IS_EXTENDED (0)
#define QPUP_AXIS_9_SET_TRAJ_VEL_LIMIT_IS_EXTENDED (0)
#define QPUP_AXIS_9_SET_TRAJ_ACCEL_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_9_SET_TRAJ_INERTIA_IS_EXTENDED (0)
#define QPUP_AXIS_9_GET_IQ_IS_EXTENDED (0)
#define QPUP_AXIS_9_GET_SENSORLESS_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_9_REBOOT_IS_EXTENDED (0)
#define QPUP_AXIS_9_GET_VBUS_VOLTAGE_IS_EXTENDED (0)
#define QPUP_AXIS_9_CLEAR_ERRORS_IS_EXTENDED (0)
#define QPUP_AXIS_9_SET_LINEAR_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_9_SET_POS_GAIN_IS_EXTENDED (0)
#define QPUP_AXIS_9_SET_VEL_GAINS_IS_EXTENDED (0)
#define QPUP_AXIS_10_HEARTBEAT_IS_EXTENDED (0)
#define QPUP_AXIS_10_ESTOP_IS_EXTENDED (0)
#define QPUP_AXIS_10_GET_MOTOR_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_10_GET_ENCODER_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_10_GET_SENSORLESS_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_10_SET_AXIS_NODE_ID_IS_EXTENDED (0)
#define QPUP_AXIS_10_SET_AXIS_STATE_IS_EXTENDED (0)
#define QPUP_AXIS_10_GET_ENCODER_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_10_GET_ENCODER_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_10_SET_CONTROLLER_MODE_IS_EXTENDED (0)
#define QPUP_AXIS_10_SET_INPUT_POS_IS_EXTENDED (0)
#define QPUP_AXIS_10_SET_INPUT_VEL_IS_EXTENDED (0)
#define QPUP_AXIS_10_SET_INPUT_TORQUE_IS_EXTENDED (0)
#define QPUP_AXIS_10_SET_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_10_START_ANTICOGGING_IS_EXTENDED (0)
#define QPUP_AXIS_10_SET_TRAJ_VEL_LIMIT_IS_EXTENDED (0)
#define QPUP_AXIS_10_SET_TRAJ_ACCEL_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_10_SET_TRAJ_INERTIA_IS_EXTENDED (0)
#define QPUP_AXIS_10_GET_IQ_IS_EXTENDED (0)
#define QPUP_AXIS_10_GET_SENSORLESS_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_10_REBOOT_IS_EXTENDED (0)
#define QPUP_AXIS_10_GET_VBUS_VOLTAGE_IS_EXTENDED (0)
#define QPUP_AXIS_10_CLEAR_ERRORS_IS_EXTENDED (0)
#define QPUP_AXIS_10_SET_LINEAR_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_10_SET_POS_GAIN_IS_EXTENDED (0)
#define QPUP_AXIS_10_SET_VEL_GAINS_IS_EXTENDED (0)
#define QPUP_AXIS_11_HEARTBEAT_IS_EXTENDED (0)
#define QPUP_AXIS_11_ESTOP_IS_EXTENDED (0)
#define QPUP_AXIS_11_GET_MOTOR_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_11_GET_ENCODER_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_11_GET_SENSORLESS_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_11_SET_AXIS_NODE_ID_IS_EXTENDED (0)
#define QPUP_AXIS_11_SET_AXIS_STATE_IS_EXTENDED (0)
#define QPUP_AXIS_11_GET_ENCODER_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_11_GET_ENCODER_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_11_SET_CONTROLLER_MODE_IS_EXTENDED (0)
#define QPUP_AXIS_11_SET_INPUT_POS_IS_EXTENDED (0)
#define QPUP_AXIS_11_SET_INPUT_VEL_IS_EXTENDED (0)
#define QPUP_AXIS_11_SET_INPUT_TORQUE_IS_EXTENDED (0)
#define QPUP_AXIS_11_SET_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_11_START_ANTICOGGING_IS_EXTENDED (0)
#define QPUP_AXIS_11_SET_TRAJ_VEL_LIMIT_IS_EXTENDED (0)
#define QPUP_AXIS_11_SET_TRAJ_ACCEL_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_11_SET_TRAJ_INERTIA_IS_EXTENDED (0)
#define QPUP_AXIS_11_GET_IQ_IS_EXTENDED (0)
#define QPUP_AXIS_11_GET_SENSORLESS_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_11_REBOOT_IS_EXTENDED (0)
#define QPUP_AXIS_11_GET_VBUS_VOLTAGE_IS_EXTENDED (0)
#define QPUP_AXIS_11_CLEAR_ERRORS_IS_EXTENDED (0)
#define QPUP_AXIS_11_SET_LINEAR_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_11_SET_POS_GAIN_IS_EXTENDED (0)
#define QPUP_AXIS_11_SET_VEL_GAINS_IS_EXTENDED (0)
#define QPUP_AXIS_12_HEARTBEAT_IS_EXTENDED (0)
#define QPUP_AXIS_12_ESTOP_IS_EXTENDED (0)
#define QPUP_AXIS_12_GET_MOTOR_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_12_GET_ENCODER_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_12_GET_SENSORLESS_ERROR_IS_EXTENDED (0)
#define QPUP_AXIS_12_SET_AXIS_NODE_ID_IS_EXTENDED (0)
#define QPUP_AXIS_12_SET_AXIS_STATE_IS_EXTENDED (0)
#define QPUP_AXIS_12_GET_ENCODER_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_12_GET_ENCODER_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_12_SET_CONTROLLER_MODE_IS_EXTENDED (0)
#define QPUP_AXIS_12_SET_INPUT_POS_IS_EXTENDED (0)
#define QPUP_AXIS_12_SET_INPUT_VEL_IS_EXTENDED (0)
#define QPUP_AXIS_12_SET_INPUT_TORQUE_IS_EXTENDED (0)
#define QPUP_AXIS_12_SET_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_12_START_ANTICOGGING_IS_EXTENDED (0)
#define QPUP_AXIS_12_SET_TRAJ_VEL_LIMIT_IS_EXTENDED (0)
#define QPUP_AXIS_12_SET_TRAJ_ACCEL_LIMITS_IS_EXTENDED (0)
#define QPUP_AXIS_12_SET_TRAJ_INERTIA_IS_EXTENDED (0)
#define QPUP_AXIS_12_GET_IQ_IS_EXTENDED (0)
#define QPUP_AXIS_12_GET_SENSORLESS_ESTIMATES_IS_EXTENDED (0)
#define QPUP_AXIS_12_REBOOT_IS_EXTENDED (0)
#define QPUP_AXIS_12_GET_VBUS_VOLTAGE_IS_EXTENDED (0)
#define QPUP_AXIS_12_CLEAR_ERRORS_IS_EXTENDED (0)
#define QPUP_AXIS_12_SET_LINEAR_COUNT_IS_EXTENDED (0)
#define QPUP_AXIS_12_SET_POS_GAIN_IS_EXTENDED (0)
#define QPUP_AXIS_12_SET_VEL_GAINS_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */


/**
 * Signals in message Odrive_Heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t axis_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t motor_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t controller_flags;
};

/**
 * Signals in message Odrive_Estop.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_estop_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Odrive_Get_Motor_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_get_motor_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_error;
};

/**
 * Signals in message Odrive_Get_Encoder_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_get_encoder_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t encoder_error;
};

/**
 * Signals in message Odrive_Get_Sensorless_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_get_sensorless_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t sensorless_error;
};

/**
 * Signals in message Odrive_Set_Axis_Node_ID.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_set_axis_node_id_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_node_id;
};

/**
 * Signals in message Odrive_Set_Axis_State.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_set_axis_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_requested_state;
};

/**
 * Signals in message Odrive_Get_Encoder_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_get_encoder_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_estimate;
};

/**
 * Signals in message Odrive_Get_Encoder_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_get_encoder_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t shadow_count;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t count_in_cpr;
};

/**
 * Signals in message Odrive_Set_Controller_Mode.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_set_controller_mode_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t control_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_mode;
};

/**
 * Signals in message Odrive_Set_Input_Pos.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_set_input_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_pos;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t vel_ff;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_ff;
};

/**
 * Signals in message Odrive_Set_Input_Vel.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_set_input_vel_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque_ff;
};

/**
 * Signals in message Odrive_Set_Input_Torque.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_set_input_torque_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque;
};

/**
 * Signals in message Odrive_Set_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_set_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float current_limit;
};

/**
 * Signals in message Odrive_Start_Anticogging.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_start_anticogging_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Odrive_Set_Traj_Vel_Limit.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_set_traj_vel_limit_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_vel_limit;
};

/**
 * Signals in message Odrive_Set_Traj_Accel_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_set_traj_accel_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_accel_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_decel_limit;
};

/**
 * Signals in message Odrive_Set_Traj_Inertia.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_set_traj_inertia_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_inertia;
};

/**
 * Signals in message Odrive_Get_Iq.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_get_iq_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_measured;
};

/**
 * Signals in message Odrive_Get_Sensorless_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_get_sensorless_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_vel_estimate;
};

/**
 * Signals in message Odrive_Reboot.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_reboot_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Odrive_Get_Vbus_Voltage.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_get_vbus_voltage_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vbus_voltage;
};

/**
 * Signals in message Odrive_Clear_Errors.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Odrive_Set_Linear_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_set_linear_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t position;
};

/**
 * Signals in message Odrive_Set_Pos_Gain.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_set_pos_gain_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_gain;
};

/**
 * Signals in message Odrive_Set_Vel_gains.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_odrive_set_vel_gains_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_gain;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_integrator_gain;
};

/**
 * Signals in message Axis_1_Heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t axis_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t motor_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t controller_flags;
};

/**
 * Signals in message Axis_1_Estop.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_estop_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_1_Get_Motor_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_get_motor_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_error;
};

/**
 * Signals in message Axis_1_Get_Encoder_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_get_encoder_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t encoder_error;
};

/**
 * Signals in message Axis_1_Get_Sensorless_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_get_sensorless_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t sensorless_error;
};

/**
 * Signals in message Axis_1_Set_Axis_Node_ID.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_set_axis_node_id_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_node_id;
};

/**
 * Signals in message Axis_1_Set_Axis_State.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_set_axis_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_requested_state;
};

/**
 * Signals in message Axis_1_Get_Encoder_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_get_encoder_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_estimate;
};

/**
 * Signals in message Axis_1_Get_Encoder_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_get_encoder_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t shadow_count;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t count_in_cpr;
};

/**
 * Signals in message Axis_1_Set_Controller_Mode.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_set_controller_mode_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t control_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_mode;
};

/**
 * Signals in message Axis_1_Set_Input_Pos.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_set_input_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_pos;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t vel_ff;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_ff;
};

/**
 * Signals in message Axis_1_Set_Input_Vel.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_set_input_vel_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque_ff;
};

/**
 * Signals in message Axis_1_Set_Input_Torque.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_set_input_torque_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque;
};

/**
 * Signals in message Axis_1_Set_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_set_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float current_limit;
};

/**
 * Signals in message Axis_1_Start_Anticogging.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_start_anticogging_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_1_Set_Traj_Vel_Limit.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_set_traj_vel_limit_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_vel_limit;
};

/**
 * Signals in message Axis_1_Set_Traj_Accel_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_set_traj_accel_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_accel_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_decel_limit;
};

/**
 * Signals in message Axis_1_Set_Traj_Inertia.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_set_traj_inertia_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_inertia;
};

/**
 * Signals in message Axis_1_Get_Iq.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_get_iq_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_measured;
};

/**
 * Signals in message Axis_1_Get_Sensorless_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_get_sensorless_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_vel_estimate;
};

/**
 * Signals in message Axis_1_Reboot.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_reboot_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_1_Get_Vbus_Voltage.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_get_vbus_voltage_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vbus_voltage;
};

/**
 * Signals in message Axis_1_Clear_Errors.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_1_Set_Linear_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_set_linear_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t position;
};

/**
 * Signals in message Axis_1_Set_Pos_Gain.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_set_pos_gain_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_gain;
};

/**
 * Signals in message Axis_1_Set_Vel_gains.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_1_set_vel_gains_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_gain;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_integrator_gain;
};

/**
 * Signals in message Axis_2_Heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t axis_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t motor_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t controller_flags;
};

/**
 * Signals in message Axis_2_Estop.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_estop_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_2_Get_Motor_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_get_motor_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_error;
};

/**
 * Signals in message Axis_2_Get_Encoder_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_get_encoder_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t encoder_error;
};

/**
 * Signals in message Axis_2_Get_Sensorless_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_get_sensorless_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t sensorless_error;
};

/**
 * Signals in message Axis_2_Set_Axis_Node_ID.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_set_axis_node_id_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_node_id;
};

/**
 * Signals in message Axis_2_Set_Axis_State.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_set_axis_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_requested_state;
};

/**
 * Signals in message Axis_2_Get_Encoder_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_get_encoder_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_estimate;
};

/**
 * Signals in message Axis_2_Get_Encoder_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_get_encoder_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t shadow_count;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t count_in_cpr;
};

/**
 * Signals in message Axis_2_Set_Controller_Mode.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_set_controller_mode_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t control_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_mode;
};

/**
 * Signals in message Axis_2_Set_Input_Pos.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_set_input_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_pos;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t vel_ff;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_ff;
};

/**
 * Signals in message Axis_2_Set_Input_Vel.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_set_input_vel_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque_ff;
};

/**
 * Signals in message Axis_2_Set_Input_Torque.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_set_input_torque_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque;
};

/**
 * Signals in message Axis_2_Set_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_set_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float current_limit;
};

/**
 * Signals in message Axis_2_Start_Anticogging.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_start_anticogging_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_2_Set_Traj_Vel_Limit.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_set_traj_vel_limit_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_vel_limit;
};

/**
 * Signals in message Axis_2_Set_Traj_Accel_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_set_traj_accel_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_accel_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_decel_limit;
};

/**
 * Signals in message Axis_2_Set_Traj_Inertia.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_set_traj_inertia_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_inertia;
};

/**
 * Signals in message Axis_2_Get_Iq.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_get_iq_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_measured;
};

/**
 * Signals in message Axis_2_Get_Sensorless_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_get_sensorless_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_vel_estimate;
};

/**
 * Signals in message Axis_2_Reboot.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_reboot_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_2_Get_Vbus_Voltage.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_get_vbus_voltage_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vbus_voltage;
};

/**
 * Signals in message Axis_2_Clear_Errors.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_2_Set_Linear_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_set_linear_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t position;
};

/**
 * Signals in message Axis_2_Set_Pos_Gain.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_set_pos_gain_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_gain;
};

/**
 * Signals in message Axis_2_Set_Vel_gains.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_2_set_vel_gains_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_gain;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_integrator_gain;
};

/**
 * Signals in message Axis_3_Heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t axis_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t motor_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t controller_flags;
};

/**
 * Signals in message Axis_3_Estop.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_estop_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_3_Get_Motor_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_get_motor_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_error;
};

/**
 * Signals in message Axis_3_Get_Encoder_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_get_encoder_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t encoder_error;
};

/**
 * Signals in message Axis_3_Get_Sensorless_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_get_sensorless_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t sensorless_error;
};

/**
 * Signals in message Axis_3_Set_Axis_Node_ID.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_set_axis_node_id_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_node_id;
};

/**
 * Signals in message Axis_3_Set_Axis_State.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_set_axis_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_requested_state;
};

/**
 * Signals in message Axis_3_Get_Encoder_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_get_encoder_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_estimate;
};

/**
 * Signals in message Axis_3_Get_Encoder_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_get_encoder_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t shadow_count;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t count_in_cpr;
};

/**
 * Signals in message Axis_3_Set_Controller_Mode.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_set_controller_mode_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t control_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_mode;
};

/**
 * Signals in message Axis_3_Set_Input_Pos.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_set_input_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_pos;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t vel_ff;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_ff;
};

/**
 * Signals in message Axis_3_Set_Input_Vel.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_set_input_vel_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque_ff;
};

/**
 * Signals in message Axis_3_Set_Input_Torque.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_set_input_torque_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque;
};

/**
 * Signals in message Axis_3_Set_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_set_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float current_limit;
};

/**
 * Signals in message Axis_3_Start_Anticogging.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_start_anticogging_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_3_Set_Traj_Vel_Limit.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_set_traj_vel_limit_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_vel_limit;
};

/**
 * Signals in message Axis_3_Set_Traj_Accel_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_set_traj_accel_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_accel_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_decel_limit;
};

/**
 * Signals in message Axis_3_Set_Traj_Inertia.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_set_traj_inertia_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_inertia;
};

/**
 * Signals in message Axis_3_Get_Iq.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_get_iq_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_measured;
};

/**
 * Signals in message Axis_3_Get_Sensorless_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_get_sensorless_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_vel_estimate;
};

/**
 * Signals in message Axis_3_Reboot.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_reboot_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_3_Get_Vbus_Voltage.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_get_vbus_voltage_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vbus_voltage;
};

/**
 * Signals in message Axis_3_Clear_Errors.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_3_Set_Linear_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_set_linear_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t position;
};

/**
 * Signals in message Axis_3_Set_Pos_Gain.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_set_pos_gain_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_gain;
};

/**
 * Signals in message Axis_3_Set_Vel_gains.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_3_set_vel_gains_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_gain;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_integrator_gain;
};

/**
 * Signals in message Axis_4_Heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t axis_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t motor_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t controller_flags;
};

/**
 * Signals in message Axis_4_Estop.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_estop_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_4_Get_Motor_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_get_motor_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_error;
};

/**
 * Signals in message Axis_4_Get_Encoder_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_get_encoder_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t encoder_error;
};

/**
 * Signals in message Axis_4_Get_Sensorless_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_get_sensorless_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t sensorless_error;
};

/**
 * Signals in message Axis_4_Set_Axis_Node_ID.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_set_axis_node_id_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_node_id;
};

/**
 * Signals in message Axis_4_Set_Axis_State.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_set_axis_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_requested_state;
};

/**
 * Signals in message Axis_4_Get_Encoder_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_get_encoder_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_estimate;
};

/**
 * Signals in message Axis_4_Get_Encoder_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_get_encoder_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t shadow_count;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t count_in_cpr;
};

/**
 * Signals in message Axis_4_Set_Controller_Mode.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_set_controller_mode_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t control_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_mode;
};

/**
 * Signals in message Axis_4_Set_Input_Pos.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_set_input_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_pos;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t vel_ff;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_ff;
};

/**
 * Signals in message Axis_4_Set_Input_Vel.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_set_input_vel_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque_ff;
};

/**
 * Signals in message Axis_4_Set_Input_Torque.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_set_input_torque_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque;
};

/**
 * Signals in message Axis_4_Set_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_set_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float current_limit;
};

/**
 * Signals in message Axis_4_Start_Anticogging.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_start_anticogging_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_4_Set_Traj_Vel_Limit.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_set_traj_vel_limit_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_vel_limit;
};

/**
 * Signals in message Axis_4_Set_Traj_Accel_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_set_traj_accel_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_accel_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_decel_limit;
};

/**
 * Signals in message Axis_4_Set_Traj_Inertia.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_set_traj_inertia_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_inertia;
};

/**
 * Signals in message Axis_4_Get_Iq.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_get_iq_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_measured;
};

/**
 * Signals in message Axis_4_Get_Sensorless_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_get_sensorless_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_vel_estimate;
};

/**
 * Signals in message Axis_4_Reboot.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_reboot_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_4_Get_Vbus_Voltage.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_get_vbus_voltage_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vbus_voltage;
};

/**
 * Signals in message Axis_4_Clear_Errors.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_4_Set_Linear_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_set_linear_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t position;
};

/**
 * Signals in message Axis_4_Set_Pos_Gain.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_set_pos_gain_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_gain;
};

/**
 * Signals in message Axis_4_Set_Vel_gains.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_4_set_vel_gains_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_gain;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_integrator_gain;
};

/**
 * Signals in message Axis_5_Heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t axis_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t motor_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t controller_flags;
};

/**
 * Signals in message Axis_5_Estop.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_estop_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_5_Get_Motor_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_get_motor_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_error;
};

/**
 * Signals in message Axis_5_Get_Encoder_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_get_encoder_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t encoder_error;
};

/**
 * Signals in message Axis_5_Get_Sensorless_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_get_sensorless_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t sensorless_error;
};

/**
 * Signals in message Axis_5_Set_Axis_Node_ID.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_set_axis_node_id_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_node_id;
};

/**
 * Signals in message Axis_5_Set_Axis_State.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_set_axis_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_requested_state;
};

/**
 * Signals in message Axis_5_Get_Encoder_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_get_encoder_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_estimate;
};

/**
 * Signals in message Axis_5_Get_Encoder_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_get_encoder_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t shadow_count;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t count_in_cpr;
};

/**
 * Signals in message Axis_5_Set_Controller_Mode.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_set_controller_mode_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t control_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_mode;
};

/**
 * Signals in message Axis_5_Set_Input_Pos.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_set_input_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_pos;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t vel_ff;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_ff;
};

/**
 * Signals in message Axis_5_Set_Input_Vel.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_set_input_vel_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque_ff;
};

/**
 * Signals in message Axis_5_Set_Input_Torque.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_set_input_torque_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque;
};

/**
 * Signals in message Axis_5_Set_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_set_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float current_limit;
};

/**
 * Signals in message Axis_5_Start_Anticogging.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_start_anticogging_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_5_Set_Traj_Vel_Limit.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_set_traj_vel_limit_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_vel_limit;
};

/**
 * Signals in message Axis_5_Set_Traj_Accel_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_set_traj_accel_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_accel_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_decel_limit;
};

/**
 * Signals in message Axis_5_Set_Traj_Inertia.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_set_traj_inertia_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_inertia;
};

/**
 * Signals in message Axis_5_Get_Iq.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_get_iq_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_measured;
};

/**
 * Signals in message Axis_5_Get_Sensorless_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_get_sensorless_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_vel_estimate;
};

/**
 * Signals in message Axis_5_Reboot.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_reboot_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_5_Get_Vbus_Voltage.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_get_vbus_voltage_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vbus_voltage;
};

/**
 * Signals in message Axis_5_Clear_Errors.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_5_Set_Linear_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_set_linear_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t position;
};

/**
 * Signals in message Axis_5_Set_Pos_Gain.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_set_pos_gain_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_gain;
};

/**
 * Signals in message Axis_5_Set_Vel_gains.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_5_set_vel_gains_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_gain;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_integrator_gain;
};

/**
 * Signals in message Axis_6_Heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t axis_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t motor_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t controller_flags;
};

/**
 * Signals in message Axis_6_Estop.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_estop_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_6_Get_Motor_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_get_motor_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_error;
};

/**
 * Signals in message Axis_6_Get_Encoder_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_get_encoder_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t encoder_error;
};

/**
 * Signals in message Axis_6_Get_Sensorless_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_get_sensorless_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t sensorless_error;
};

/**
 * Signals in message Axis_6_Set_Axis_Node_ID.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_set_axis_node_id_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_node_id;
};

/**
 * Signals in message Axis_6_Set_Axis_State.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_set_axis_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_requested_state;
};

/**
 * Signals in message Axis_6_Get_Encoder_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_get_encoder_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_estimate;
};

/**
 * Signals in message Axis_6_Get_Encoder_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_get_encoder_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t shadow_count;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t count_in_cpr;
};

/**
 * Signals in message Axis_6_Set_Controller_Mode.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_set_controller_mode_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t control_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_mode;
};

/**
 * Signals in message Axis_6_Set_Input_Pos.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_set_input_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_pos;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t vel_ff;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_ff;
};

/**
 * Signals in message Axis_6_Set_Input_Vel.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_set_input_vel_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque_ff;
};

/**
 * Signals in message Axis_6_Set_Input_Torque.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_set_input_torque_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque;
};

/**
 * Signals in message Axis_6_Set_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_set_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float current_limit;
};

/**
 * Signals in message Axis_6_Start_Anticogging.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_start_anticogging_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_6_Set_Traj_Vel_Limit.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_set_traj_vel_limit_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_vel_limit;
};

/**
 * Signals in message Axis_6_Set_Traj_Accel_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_set_traj_accel_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_accel_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_decel_limit;
};

/**
 * Signals in message Axis_6_Set_Traj_Inertia.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_set_traj_inertia_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_inertia;
};

/**
 * Signals in message Axis_6_Get_Iq.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_get_iq_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_measured;
};

/**
 * Signals in message Axis_6_Get_Sensorless_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_get_sensorless_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_vel_estimate;
};

/**
 * Signals in message Axis_6_Reboot.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_reboot_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_6_Get_Vbus_Voltage.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_get_vbus_voltage_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vbus_voltage;
};

/**
 * Signals in message Axis_6_Clear_Errors.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_6_Set_Linear_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_set_linear_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t position;
};

/**
 * Signals in message Axis_6_Set_Pos_Gain.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_set_pos_gain_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_gain;
};

/**
 * Signals in message Axis_6_Set_Vel_gains.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_6_set_vel_gains_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_gain;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_integrator_gain;
};

/**
 * Signals in message Axis_7_Heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t axis_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t motor_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t controller_flags;
};

/**
 * Signals in message Axis_7_Estop.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_estop_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_7_Get_Motor_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_get_motor_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_error;
};

/**
 * Signals in message Axis_7_Get_Encoder_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_get_encoder_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t encoder_error;
};

/**
 * Signals in message Axis_7_Get_Sensorless_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_get_sensorless_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t sensorless_error;
};

/**
 * Signals in message Axis_7_Set_Axis_Node_ID.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_set_axis_node_id_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_node_id;
};

/**
 * Signals in message Axis_7_Set_Axis_State.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_set_axis_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_requested_state;
};

/**
 * Signals in message Axis_7_Get_Encoder_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_get_encoder_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_estimate;
};

/**
 * Signals in message Axis_7_Get_Encoder_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_get_encoder_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t shadow_count;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t count_in_cpr;
};

/**
 * Signals in message Axis_7_Set_Controller_Mode.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_set_controller_mode_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t control_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_mode;
};

/**
 * Signals in message Axis_7_Set_Input_Pos.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_set_input_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_pos;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t vel_ff;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_ff;
};

/**
 * Signals in message Axis_7_Set_Input_Vel.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_set_input_vel_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque_ff;
};

/**
 * Signals in message Axis_7_Set_Input_Torque.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_set_input_torque_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque;
};

/**
 * Signals in message Axis_7_Set_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_set_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float current_limit;
};

/**
 * Signals in message Axis_7_Start_Anticogging.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_start_anticogging_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_7_Set_Traj_Vel_Limit.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_set_traj_vel_limit_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_vel_limit;
};

/**
 * Signals in message Axis_7_Set_Traj_Accel_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_set_traj_accel_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_accel_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_decel_limit;
};

/**
 * Signals in message Axis_7_Set_Traj_Inertia.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_set_traj_inertia_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_inertia;
};

/**
 * Signals in message Axis_7_Get_Iq.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_get_iq_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_measured;
};

/**
 * Signals in message Axis_7_Get_Sensorless_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_get_sensorless_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_vel_estimate;
};

/**
 * Signals in message Axis_7_Reboot.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_reboot_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_7_Get_Vbus_Voltage.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_get_vbus_voltage_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vbus_voltage;
};

/**
 * Signals in message Axis_7_Clear_Errors.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_7_Set_Linear_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_set_linear_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t position;
};

/**
 * Signals in message Axis_7_Set_Pos_Gain.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_set_pos_gain_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_gain;
};

/**
 * Signals in message Axis_7_Set_Vel_gains.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_7_set_vel_gains_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_gain;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_integrator_gain;
};

/**
 * Signals in message Axis_8_Heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t axis_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t motor_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t controller_flags;
};

/**
 * Signals in message Axis_8_Estop.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_estop_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_8_Get_Motor_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_get_motor_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_error;
};

/**
 * Signals in message Axis_8_Get_Encoder_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_get_encoder_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t encoder_error;
};

/**
 * Signals in message Axis_8_Get_Sensorless_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_get_sensorless_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t sensorless_error;
};

/**
 * Signals in message Axis_8_Set_Axis_Node_ID.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_set_axis_node_id_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_node_id;
};

/**
 * Signals in message Axis_8_Set_Axis_State.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_set_axis_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_requested_state;
};

/**
 * Signals in message Axis_8_Get_Encoder_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_get_encoder_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_estimate;
};

/**
 * Signals in message Axis_8_Get_Encoder_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_get_encoder_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t shadow_count;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t count_in_cpr;
};

/**
 * Signals in message Axis_8_Set_Controller_Mode.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_set_controller_mode_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t control_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_mode;
};

/**
 * Signals in message Axis_8_Set_Input_Pos.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_set_input_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_pos;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t vel_ff;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_ff;
};

/**
 * Signals in message Axis_8_Set_Input_Vel.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_set_input_vel_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque_ff;
};

/**
 * Signals in message Axis_8_Set_Input_Torque.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_set_input_torque_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque;
};

/**
 * Signals in message Axis_8_Set_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_set_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float current_limit;
};

/**
 * Signals in message Axis_8_Start_Anticogging.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_start_anticogging_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_8_Set_Traj_Vel_Limit.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_set_traj_vel_limit_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_vel_limit;
};

/**
 * Signals in message Axis_8_Set_Traj_Accel_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_set_traj_accel_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_accel_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_decel_limit;
};

/**
 * Signals in message Axis_8_Set_Traj_Inertia.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_set_traj_inertia_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_inertia;
};

/**
 * Signals in message Axis_8_Get_Iq.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_get_iq_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_measured;
};

/**
 * Signals in message Axis_8_Get_Sensorless_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_get_sensorless_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_vel_estimate;
};

/**
 * Signals in message Axis_8_Reboot.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_reboot_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_8_Get_Vbus_Voltage.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_get_vbus_voltage_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vbus_voltage;
};

/**
 * Signals in message Axis_8_Clear_Errors.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_8_Set_Linear_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_set_linear_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t position;
};

/**
 * Signals in message Axis_8_Set_Pos_Gain.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_set_pos_gain_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_gain;
};

/**
 * Signals in message Axis_8_Set_Vel_gains.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_8_set_vel_gains_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_gain;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_integrator_gain;
};

/**
 * Signals in message Axis_9_Heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t axis_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t motor_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t controller_flags;
};

/**
 * Signals in message Axis_9_Estop.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_estop_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_9_Get_Motor_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_get_motor_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_error;
};

/**
 * Signals in message Axis_9_Get_Encoder_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_get_encoder_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t encoder_error;
};

/**
 * Signals in message Axis_9_Get_Sensorless_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_get_sensorless_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t sensorless_error;
};

/**
 * Signals in message Axis_9_Set_Axis_Node_ID.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_set_axis_node_id_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_node_id;
};

/**
 * Signals in message Axis_9_Set_Axis_State.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_set_axis_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_requested_state;
};

/**
 * Signals in message Axis_9_Get_Encoder_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_get_encoder_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_estimate;
};

/**
 * Signals in message Axis_9_Get_Encoder_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_get_encoder_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t shadow_count;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t count_in_cpr;
};

/**
 * Signals in message Axis_9_Set_Controller_Mode.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_set_controller_mode_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t control_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_mode;
};

/**
 * Signals in message Axis_9_Set_Input_Pos.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_set_input_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_pos;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t vel_ff;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_ff;
};

/**
 * Signals in message Axis_9_Set_Input_Vel.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_set_input_vel_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque_ff;
};

/**
 * Signals in message Axis_9_Set_Input_Torque.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_set_input_torque_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque;
};

/**
 * Signals in message Axis_9_Set_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_set_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float current_limit;
};

/**
 * Signals in message Axis_9_Start_Anticogging.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_start_anticogging_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_9_Set_Traj_Vel_Limit.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_set_traj_vel_limit_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_vel_limit;
};

/**
 * Signals in message Axis_9_Set_Traj_Accel_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_set_traj_accel_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_accel_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_decel_limit;
};

/**
 * Signals in message Axis_9_Set_Traj_Inertia.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_set_traj_inertia_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_inertia;
};

/**
 * Signals in message Axis_9_Get_Iq.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_get_iq_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_measured;
};

/**
 * Signals in message Axis_9_Get_Sensorless_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_get_sensorless_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_vel_estimate;
};

/**
 * Signals in message Axis_9_Reboot.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_reboot_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_9_Get_Vbus_Voltage.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_get_vbus_voltage_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vbus_voltage;
};

/**
 * Signals in message Axis_9_Clear_Errors.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_9_Set_Linear_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_set_linear_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t position;
};

/**
 * Signals in message Axis_9_Set_Pos_Gain.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_set_pos_gain_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_gain;
};

/**
 * Signals in message Axis_9_Set_Vel_gains.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_9_set_vel_gains_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_gain;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_integrator_gain;
};

/**
 * Signals in message Axis_10_Heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t axis_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t motor_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t controller_flags;
};

/**
 * Signals in message Axis_10_Estop.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_estop_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_10_Get_Motor_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_get_motor_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_error;
};

/**
 * Signals in message Axis_10_Get_Encoder_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_get_encoder_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t encoder_error;
};

/**
 * Signals in message Axis_10_Get_Sensorless_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_get_sensorless_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t sensorless_error;
};

/**
 * Signals in message Axis_10_Set_Axis_Node_ID.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_set_axis_node_id_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_node_id;
};

/**
 * Signals in message Axis_10_Set_Axis_State.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_set_axis_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_requested_state;
};

/**
 * Signals in message Axis_10_Get_Encoder_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_get_encoder_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_estimate;
};

/**
 * Signals in message Axis_10_Get_Encoder_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_get_encoder_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t shadow_count;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t count_in_cpr;
};

/**
 * Signals in message Axis_10_Set_Controller_Mode.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_set_controller_mode_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t control_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_mode;
};

/**
 * Signals in message Axis_10_Set_Input_Pos.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_set_input_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_pos;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t vel_ff;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_ff;
};

/**
 * Signals in message Axis_10_Set_Input_Vel.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_set_input_vel_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque_ff;
};

/**
 * Signals in message Axis_10_Set_Input_Torque.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_set_input_torque_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque;
};

/**
 * Signals in message Axis_10_Set_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_set_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float current_limit;
};

/**
 * Signals in message Axis_10_Start_Anticogging.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_start_anticogging_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_10_Set_Traj_Vel_Limit.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_set_traj_vel_limit_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_vel_limit;
};

/**
 * Signals in message Axis_10_Set_Traj_Accel_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_set_traj_accel_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_accel_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_decel_limit;
};

/**
 * Signals in message Axis_10_Set_Traj_Inertia.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_set_traj_inertia_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_inertia;
};

/**
 * Signals in message Axis_10_Get_Iq.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_get_iq_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_measured;
};

/**
 * Signals in message Axis_10_Get_Sensorless_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_get_sensorless_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_vel_estimate;
};

/**
 * Signals in message Axis_10_Reboot.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_reboot_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_10_Get_Vbus_Voltage.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_get_vbus_voltage_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vbus_voltage;
};

/**
 * Signals in message Axis_10_Clear_Errors.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_10_Set_Linear_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_set_linear_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t position;
};

/**
 * Signals in message Axis_10_Set_Pos_Gain.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_set_pos_gain_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_gain;
};

/**
 * Signals in message Axis_10_Set_Vel_gains.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_10_set_vel_gains_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_gain;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_integrator_gain;
};

/**
 * Signals in message Axis_11_Heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t axis_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t motor_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t controller_flags;
};

/**
 * Signals in message Axis_11_Estop.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_estop_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_11_Get_Motor_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_get_motor_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_error;
};

/**
 * Signals in message Axis_11_Get_Encoder_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_get_encoder_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t encoder_error;
};

/**
 * Signals in message Axis_11_Get_Sensorless_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_get_sensorless_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t sensorless_error;
};

/**
 * Signals in message Axis_11_Set_Axis_Node_ID.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_set_axis_node_id_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_node_id;
};

/**
 * Signals in message Axis_11_Set_Axis_State.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_set_axis_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_requested_state;
};

/**
 * Signals in message Axis_11_Get_Encoder_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_get_encoder_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_estimate;
};

/**
 * Signals in message Axis_11_Get_Encoder_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_get_encoder_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t shadow_count;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t count_in_cpr;
};

/**
 * Signals in message Axis_11_Set_Controller_Mode.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_set_controller_mode_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t control_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_mode;
};

/**
 * Signals in message Axis_11_Set_Input_Pos.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_set_input_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_pos;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t vel_ff;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_ff;
};

/**
 * Signals in message Axis_11_Set_Input_Vel.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_set_input_vel_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque_ff;
};

/**
 * Signals in message Axis_11_Set_Input_Torque.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_set_input_torque_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque;
};

/**
 * Signals in message Axis_11_Set_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_set_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float current_limit;
};

/**
 * Signals in message Axis_11_Start_Anticogging.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_start_anticogging_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_11_Set_Traj_Vel_Limit.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_set_traj_vel_limit_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_vel_limit;
};

/**
 * Signals in message Axis_11_Set_Traj_Accel_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_set_traj_accel_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_accel_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_decel_limit;
};

/**
 * Signals in message Axis_11_Set_Traj_Inertia.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_set_traj_inertia_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_inertia;
};

/**
 * Signals in message Axis_11_Get_Iq.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_get_iq_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_measured;
};

/**
 * Signals in message Axis_11_Get_Sensorless_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_get_sensorless_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_vel_estimate;
};

/**
 * Signals in message Axis_11_Reboot.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_reboot_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_11_Get_Vbus_Voltage.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_get_vbus_voltage_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vbus_voltage;
};

/**
 * Signals in message Axis_11_Clear_Errors.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_11_Set_Linear_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_set_linear_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t position;
};

/**
 * Signals in message Axis_11_Set_Pos_Gain.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_set_pos_gain_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_gain;
};

/**
 * Signals in message Axis_11_Set_Vel_gains.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_11_set_vel_gains_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_gain;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_integrator_gain;
};

/**
 * Signals in message Axis_12_Heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t axis_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t motor_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t controller_flags;
};

/**
 * Signals in message Axis_12_Estop.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_estop_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_12_Get_Motor_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_get_motor_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_error;
};

/**
 * Signals in message Axis_12_Get_Encoder_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_get_encoder_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t encoder_error;
};

/**
 * Signals in message Axis_12_Get_Sensorless_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_get_sensorless_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t sensorless_error;
};

/**
 * Signals in message Axis_12_Set_Axis_Node_ID.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_set_axis_node_id_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_node_id;
};

/**
 * Signals in message Axis_12_Set_Axis_State.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_set_axis_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_requested_state;
};

/**
 * Signals in message Axis_12_Get_Encoder_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_get_encoder_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_estimate;
};

/**
 * Signals in message Axis_12_Get_Encoder_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_get_encoder_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t shadow_count;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t count_in_cpr;
};

/**
 * Signals in message Axis_12_Set_Controller_Mode.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_set_controller_mode_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t control_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_mode;
};

/**
 * Signals in message Axis_12_Set_Input_Pos.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_set_input_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_pos;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t vel_ff;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_ff;
};

/**
 * Signals in message Axis_12_Set_Input_Vel.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_set_input_vel_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque_ff;
};

/**
 * Signals in message Axis_12_Set_Input_Torque.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_set_input_torque_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque;
};

/**
 * Signals in message Axis_12_Set_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_set_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float current_limit;
};

/**
 * Signals in message Axis_12_Start_Anticogging.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_start_anticogging_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_12_Set_Traj_Vel_Limit.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_set_traj_vel_limit_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_vel_limit;
};

/**
 * Signals in message Axis_12_Set_Traj_Accel_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_set_traj_accel_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_accel_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_decel_limit;
};

/**
 * Signals in message Axis_12_Set_Traj_Inertia.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_set_traj_inertia_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_inertia;
};

/**
 * Signals in message Axis_12_Get_Iq.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_get_iq_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_measured;
};

/**
 * Signals in message Axis_12_Get_Sensorless_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_get_sensorless_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_vel_estimate;
};

/**
 * Signals in message Axis_12_Reboot.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_reboot_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_12_Get_Vbus_Voltage.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_get_vbus_voltage_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vbus_voltage;
};

/**
 * Signals in message Axis_12_Clear_Errors.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Axis_12_Set_Linear_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_set_linear_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t position;
};

/**
 * Signals in message Axis_12_Set_Pos_Gain.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_set_pos_gain_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_gain;
};

/**
 * Signals in message Axis_12_Set_Vel_gains.
 *
 * All signal values are as on the CAN bus.
 */
struct qpup_axis_12_set_vel_gains_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_gain;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_integrator_gain;
};

/**
 * Pack message Odrive_Heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_heartbeat_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_heartbeat_unpack(
    struct qpup_odrive_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_odrive_heartbeat_axis_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_heartbeat_axis_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_heartbeat_axis_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_odrive_heartbeat_axis_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_heartbeat_axis_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_heartbeat_axis_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_odrive_heartbeat_motor_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_heartbeat_motor_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_heartbeat_motor_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_odrive_heartbeat_encoder_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_heartbeat_encoder_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_heartbeat_encoder_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_odrive_heartbeat_controller_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_heartbeat_controller_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_heartbeat_controller_flags_is_in_range(uint8_t value);

/**
 * Pack message Odrive_Estop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_estop_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_estop_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Estop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_estop_unpack(
    struct qpup_odrive_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Odrive_Get_Motor_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_get_motor_error_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_get_motor_error_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Get_Motor_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_get_motor_error_unpack(
    struct qpup_odrive_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_odrive_get_motor_error_motor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_get_motor_error_motor_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_get_motor_error_motor_error_is_in_range(uint32_t value);

/**
 * Pack message Odrive_Get_Encoder_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_get_encoder_error_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Get_Encoder_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_get_encoder_error_unpack(
    struct qpup_odrive_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_odrive_get_encoder_error_encoder_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_get_encoder_error_encoder_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_get_encoder_error_encoder_error_is_in_range(uint32_t value);

/**
 * Pack message Odrive_Get_Sensorless_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_get_sensorless_error_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_get_sensorless_error_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Get_Sensorless_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_get_sensorless_error_unpack(
    struct qpup_odrive_get_sensorless_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_odrive_get_sensorless_error_sensorless_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_get_sensorless_error_sensorless_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_get_sensorless_error_sensorless_error_is_in_range(uint32_t value);

/**
 * Pack message Odrive_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_set_axis_node_id_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_set_axis_node_id_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_set_axis_node_id_unpack(
    struct qpup_odrive_set_axis_node_id_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_odrive_set_axis_node_id_axis_node_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_axis_node_id_axis_node_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_axis_node_id_axis_node_id_is_in_range(uint32_t value);

/**
 * Pack message Odrive_Set_Axis_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_set_axis_state_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_set_axis_state_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Set_Axis_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_set_axis_state_unpack(
    struct qpup_odrive_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_odrive_set_axis_state_axis_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_axis_state_axis_requested_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_axis_state_axis_requested_state_is_in_range(uint32_t value);

/**
 * Pack message Odrive_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_get_encoder_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_get_encoder_estimates_unpack(
    struct qpup_odrive_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_get_encoder_estimates_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_get_encoder_estimates_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_get_encoder_estimates_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_get_encoder_estimates_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_get_encoder_estimates_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_get_encoder_estimates_vel_estimate_is_in_range(float value);

/**
 * Pack message Odrive_Get_Encoder_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_get_encoder_count_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Get_Encoder_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_get_encoder_count_unpack(
    struct qpup_odrive_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_odrive_get_encoder_count_shadow_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_get_encoder_count_shadow_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_get_encoder_count_shadow_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_odrive_get_encoder_count_count_in_cpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_get_encoder_count_count_in_cpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_get_encoder_count_count_in_cpr_is_in_range(uint32_t value);

/**
 * Pack message Odrive_Set_Controller_Mode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_set_controller_mode_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Set_Controller_Mode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_set_controller_mode_unpack(
    struct qpup_odrive_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_odrive_set_controller_mode_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_controller_mode_control_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_controller_mode_control_mode_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_odrive_set_controller_mode_input_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_controller_mode_input_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_controller_mode_input_mode_is_in_range(uint32_t value);

/**
 * Pack message Odrive_Set_Input_Pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_set_input_pos_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_set_input_pos_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Set_Input_Pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_set_input_pos_unpack(
    struct qpup_odrive_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_set_input_pos_input_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_input_pos_input_pos_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_input_pos_input_pos_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_odrive_set_input_pos_vel_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_input_pos_vel_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_input_pos_vel_ff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_odrive_set_input_pos_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_input_pos_torque_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_input_pos_torque_ff_is_in_range(int16_t value);

/**
 * Pack message Odrive_Set_Input_Vel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_set_input_vel_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_set_input_vel_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Set_Input_Vel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_set_input_vel_unpack(
    struct qpup_odrive_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_set_input_vel_input_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_input_vel_input_vel_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_input_vel_input_vel_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_set_input_vel_input_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_input_vel_input_torque_ff_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_input_vel_input_torque_ff_is_in_range(float value);

/**
 * Pack message Odrive_Set_Input_Torque.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_set_input_torque_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_set_input_torque_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Set_Input_Torque.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_set_input_torque_unpack(
    struct qpup_odrive_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_set_input_torque_input_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_input_torque_input_torque_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_input_torque_input_torque_is_in_range(float value);

/**
 * Pack message Odrive_Set_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_set_limits_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_set_limits_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Set_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_set_limits_unpack(
    struct qpup_odrive_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_set_limits_velocity_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_limits_velocity_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_limits_velocity_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_set_limits_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_limits_current_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_limits_current_limit_is_in_range(float value);

/**
 * Pack message Odrive_Start_Anticogging.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_start_anticogging_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_start_anticogging_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Start_Anticogging.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_start_anticogging_unpack(
    struct qpup_odrive_start_anticogging_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Odrive_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_set_traj_vel_limit_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_set_traj_vel_limit_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_set_traj_vel_limit_unpack(
    struct qpup_odrive_set_traj_vel_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_set_traj_vel_limit_traj_vel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_traj_vel_limit_traj_vel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_traj_vel_limit_traj_vel_limit_is_in_range(float value);

/**
 * Pack message Odrive_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_set_traj_accel_limits_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_set_traj_accel_limits_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_set_traj_accel_limits_unpack(
    struct qpup_odrive_set_traj_accel_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_set_traj_accel_limits_traj_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_traj_accel_limits_traj_accel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_traj_accel_limits_traj_accel_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_set_traj_accel_limits_traj_decel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_traj_accel_limits_traj_decel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_traj_accel_limits_traj_decel_limit_is_in_range(float value);

/**
 * Pack message Odrive_Set_Traj_Inertia.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_set_traj_inertia_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_set_traj_inertia_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Set_Traj_Inertia.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_set_traj_inertia_unpack(
    struct qpup_odrive_set_traj_inertia_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_set_traj_inertia_traj_inertia_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_traj_inertia_traj_inertia_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_traj_inertia_traj_inertia_is_in_range(float value);

/**
 * Pack message Odrive_Get_Iq.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_get_iq_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_get_iq_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Get_Iq.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_get_iq_unpack(
    struct qpup_odrive_get_iq_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_get_iq_iq_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_get_iq_iq_setpoint_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_get_iq_iq_setpoint_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_get_iq_iq_measured_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_get_iq_iq_measured_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_get_iq_iq_measured_is_in_range(float value);

/**
 * Pack message Odrive_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_get_sensorless_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_get_sensorless_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_get_sensorless_estimates_unpack(
    struct qpup_odrive_get_sensorless_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_get_sensorless_estimates_sensorless_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_get_sensorless_estimates_sensorless_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_get_sensorless_estimates_sensorless_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_get_sensorless_estimates_sensorless_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_get_sensorless_estimates_sensorless_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_get_sensorless_estimates_sensorless_vel_estimate_is_in_range(float value);

/**
 * Pack message Odrive_Reboot.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_reboot_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_reboot_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Reboot.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_reboot_unpack(
    struct qpup_odrive_reboot_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Odrive_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_get_vbus_voltage_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_get_vbus_voltage_unpack(
    struct qpup_odrive_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_get_vbus_voltage_vbus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_get_vbus_voltage_vbus_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_get_vbus_voltage_vbus_voltage_is_in_range(float value);

/**
 * Pack message Odrive_Clear_Errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_clear_errors_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Clear_Errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_clear_errors_unpack(
    struct qpup_odrive_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Odrive_Set_Linear_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_set_linear_count_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_set_linear_count_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Set_Linear_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_set_linear_count_unpack(
    struct qpup_odrive_set_linear_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t qpup_odrive_set_linear_count_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_linear_count_position_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_linear_count_position_is_in_range(int32_t value);

/**
 * Pack message Odrive_Set_Pos_Gain.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_set_pos_gain_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_set_pos_gain_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Set_Pos_Gain.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_set_pos_gain_unpack(
    struct qpup_odrive_set_pos_gain_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_set_pos_gain_pos_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_pos_gain_pos_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_pos_gain_pos_gain_is_in_range(float value);

/**
 * Pack message Odrive_Set_Vel_gains.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_odrive_set_vel_gains_pack(
    uint8_t *dst_p,
    const struct qpup_odrive_set_vel_gains_t *src_p,
    size_t size);

/**
 * Unpack message Odrive_Set_Vel_gains.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_odrive_set_vel_gains_unpack(
    struct qpup_odrive_set_vel_gains_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_set_vel_gains_vel_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_vel_gains_vel_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_vel_gains_vel_gain_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_odrive_set_vel_gains_vel_integrator_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_odrive_set_vel_gains_vel_integrator_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_odrive_set_vel_gains_vel_integrator_gain_is_in_range(float value);

/**
 * Pack message Axis_1_Heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_heartbeat_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_heartbeat_unpack(
    struct qpup_axis_1_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_1_heartbeat_axis_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_heartbeat_axis_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_heartbeat_axis_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_1_heartbeat_axis_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_heartbeat_axis_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_heartbeat_axis_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_1_heartbeat_motor_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_heartbeat_motor_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_heartbeat_motor_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_1_heartbeat_encoder_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_heartbeat_encoder_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_heartbeat_encoder_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_1_heartbeat_controller_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_heartbeat_controller_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_heartbeat_controller_flags_is_in_range(uint8_t value);

/**
 * Pack message Axis_1_Estop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_estop_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_estop_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Estop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_estop_unpack(
    struct qpup_axis_1_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_1_Get_Motor_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_get_motor_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_get_motor_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Get_Motor_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_get_motor_error_unpack(
    struct qpup_axis_1_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_1_get_motor_error_motor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_get_motor_error_motor_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_get_motor_error_motor_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_1_Get_Encoder_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_get_encoder_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Get_Encoder_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_get_encoder_error_unpack(
    struct qpup_axis_1_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_1_get_encoder_error_encoder_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_get_encoder_error_encoder_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_get_encoder_error_encoder_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_1_Get_Sensorless_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_get_sensorless_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_get_sensorless_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Get_Sensorless_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_get_sensorless_error_unpack(
    struct qpup_axis_1_get_sensorless_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_1_get_sensorless_error_sensorless_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_get_sensorless_error_sensorless_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_get_sensorless_error_sensorless_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_1_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_set_axis_node_id_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_set_axis_node_id_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_set_axis_node_id_unpack(
    struct qpup_axis_1_set_axis_node_id_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_1_set_axis_node_id_axis_node_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_axis_node_id_axis_node_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_axis_node_id_axis_node_id_is_in_range(uint32_t value);

/**
 * Pack message Axis_1_Set_Axis_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_set_axis_state_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_set_axis_state_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Set_Axis_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_set_axis_state_unpack(
    struct qpup_axis_1_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_1_set_axis_state_axis_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_axis_state_axis_requested_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_axis_state_axis_requested_state_is_in_range(uint32_t value);

/**
 * Pack message Axis_1_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_get_encoder_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_get_encoder_estimates_unpack(
    struct qpup_axis_1_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_get_encoder_estimates_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_get_encoder_estimates_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_get_encoder_estimates_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_get_encoder_estimates_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_get_encoder_estimates_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_get_encoder_estimates_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_1_Get_Encoder_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_get_encoder_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Get_Encoder_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_get_encoder_count_unpack(
    struct qpup_axis_1_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_1_get_encoder_count_shadow_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_get_encoder_count_shadow_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_get_encoder_count_shadow_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_1_get_encoder_count_count_in_cpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_get_encoder_count_count_in_cpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_get_encoder_count_count_in_cpr_is_in_range(uint32_t value);

/**
 * Pack message Axis_1_Set_Controller_Mode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_set_controller_mode_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Set_Controller_Mode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_set_controller_mode_unpack(
    struct qpup_axis_1_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_1_set_controller_mode_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_controller_mode_control_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_controller_mode_control_mode_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_1_set_controller_mode_input_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_controller_mode_input_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_controller_mode_input_mode_is_in_range(uint32_t value);

/**
 * Pack message Axis_1_Set_Input_Pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_set_input_pos_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_set_input_pos_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Set_Input_Pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_set_input_pos_unpack(
    struct qpup_axis_1_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_set_input_pos_input_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_input_pos_input_pos_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_input_pos_input_pos_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_1_set_input_pos_vel_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_input_pos_vel_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_input_pos_vel_ff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_1_set_input_pos_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_input_pos_torque_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_input_pos_torque_ff_is_in_range(int16_t value);

/**
 * Pack message Axis_1_Set_Input_Vel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_set_input_vel_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_set_input_vel_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Set_Input_Vel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_set_input_vel_unpack(
    struct qpup_axis_1_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_set_input_vel_input_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_input_vel_input_vel_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_input_vel_input_vel_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_set_input_vel_input_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_input_vel_input_torque_ff_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_input_vel_input_torque_ff_is_in_range(float value);

/**
 * Pack message Axis_1_Set_Input_Torque.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_set_input_torque_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_set_input_torque_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Set_Input_Torque.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_set_input_torque_unpack(
    struct qpup_axis_1_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_set_input_torque_input_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_input_torque_input_torque_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_input_torque_input_torque_is_in_range(float value);

/**
 * Pack message Axis_1_Set_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_set_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_set_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Set_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_set_limits_unpack(
    struct qpup_axis_1_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_set_limits_velocity_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_limits_velocity_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_limits_velocity_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_set_limits_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_limits_current_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_limits_current_limit_is_in_range(float value);

/**
 * Pack message Axis_1_Start_Anticogging.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_start_anticogging_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_start_anticogging_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Start_Anticogging.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_start_anticogging_unpack(
    struct qpup_axis_1_start_anticogging_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_1_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_set_traj_vel_limit_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_set_traj_vel_limit_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_set_traj_vel_limit_unpack(
    struct qpup_axis_1_set_traj_vel_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_set_traj_vel_limit_traj_vel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_traj_vel_limit_traj_vel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_traj_vel_limit_traj_vel_limit_is_in_range(float value);

/**
 * Pack message Axis_1_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_set_traj_accel_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_set_traj_accel_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_set_traj_accel_limits_unpack(
    struct qpup_axis_1_set_traj_accel_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_set_traj_accel_limits_traj_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_traj_accel_limits_traj_accel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_traj_accel_limits_traj_accel_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_set_traj_accel_limits_traj_decel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_traj_accel_limits_traj_decel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_traj_accel_limits_traj_decel_limit_is_in_range(float value);

/**
 * Pack message Axis_1_Set_Traj_Inertia.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_set_traj_inertia_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_set_traj_inertia_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Set_Traj_Inertia.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_set_traj_inertia_unpack(
    struct qpup_axis_1_set_traj_inertia_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_set_traj_inertia_traj_inertia_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_traj_inertia_traj_inertia_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_traj_inertia_traj_inertia_is_in_range(float value);

/**
 * Pack message Axis_1_Get_Iq.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_get_iq_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_get_iq_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Get_Iq.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_get_iq_unpack(
    struct qpup_axis_1_get_iq_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_get_iq_iq_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_get_iq_iq_setpoint_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_get_iq_iq_setpoint_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_get_iq_iq_measured_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_get_iq_iq_measured_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_get_iq_iq_measured_is_in_range(float value);

/**
 * Pack message Axis_1_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_get_sensorless_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_get_sensorless_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_get_sensorless_estimates_unpack(
    struct qpup_axis_1_get_sensorless_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_get_sensorless_estimates_sensorless_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_get_sensorless_estimates_sensorless_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_get_sensorless_estimates_sensorless_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_get_sensorless_estimates_sensorless_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_get_sensorless_estimates_sensorless_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_get_sensorless_estimates_sensorless_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_1_Reboot.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_reboot_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_reboot_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Reboot.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_reboot_unpack(
    struct qpup_axis_1_reboot_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_1_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_get_vbus_voltage_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_get_vbus_voltage_unpack(
    struct qpup_axis_1_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_get_vbus_voltage_vbus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_get_vbus_voltage_vbus_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_get_vbus_voltage_vbus_voltage_is_in_range(float value);

/**
 * Pack message Axis_1_Clear_Errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_clear_errors_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Clear_Errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_clear_errors_unpack(
    struct qpup_axis_1_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_1_Set_Linear_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_set_linear_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_set_linear_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Set_Linear_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_set_linear_count_unpack(
    struct qpup_axis_1_set_linear_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t qpup_axis_1_set_linear_count_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_linear_count_position_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_linear_count_position_is_in_range(int32_t value);

/**
 * Pack message Axis_1_Set_Pos_Gain.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_set_pos_gain_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_set_pos_gain_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Set_Pos_Gain.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_set_pos_gain_unpack(
    struct qpup_axis_1_set_pos_gain_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_set_pos_gain_pos_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_pos_gain_pos_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_pos_gain_pos_gain_is_in_range(float value);

/**
 * Pack message Axis_1_Set_Vel_gains.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_1_set_vel_gains_pack(
    uint8_t *dst_p,
    const struct qpup_axis_1_set_vel_gains_t *src_p,
    size_t size);

/**
 * Unpack message Axis_1_Set_Vel_gains.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_1_set_vel_gains_unpack(
    struct qpup_axis_1_set_vel_gains_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_set_vel_gains_vel_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_vel_gains_vel_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_vel_gains_vel_gain_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_1_set_vel_gains_vel_integrator_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_1_set_vel_gains_vel_integrator_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_1_set_vel_gains_vel_integrator_gain_is_in_range(float value);

/**
 * Pack message Axis_2_Heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_heartbeat_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_heartbeat_unpack(
    struct qpup_axis_2_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_2_heartbeat_axis_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_heartbeat_axis_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_heartbeat_axis_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_2_heartbeat_axis_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_heartbeat_axis_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_heartbeat_axis_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_2_heartbeat_motor_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_heartbeat_motor_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_heartbeat_motor_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_2_heartbeat_encoder_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_heartbeat_encoder_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_heartbeat_encoder_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_2_heartbeat_controller_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_heartbeat_controller_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_heartbeat_controller_flags_is_in_range(uint8_t value);

/**
 * Pack message Axis_2_Estop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_estop_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_estop_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Estop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_estop_unpack(
    struct qpup_axis_2_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_2_Get_Motor_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_get_motor_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_get_motor_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Get_Motor_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_get_motor_error_unpack(
    struct qpup_axis_2_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_2_get_motor_error_motor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_get_motor_error_motor_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_get_motor_error_motor_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_2_Get_Encoder_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_get_encoder_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Get_Encoder_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_get_encoder_error_unpack(
    struct qpup_axis_2_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_2_get_encoder_error_encoder_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_get_encoder_error_encoder_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_get_encoder_error_encoder_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_2_Get_Sensorless_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_get_sensorless_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_get_sensorless_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Get_Sensorless_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_get_sensorless_error_unpack(
    struct qpup_axis_2_get_sensorless_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_2_get_sensorless_error_sensorless_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_get_sensorless_error_sensorless_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_get_sensorless_error_sensorless_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_2_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_set_axis_node_id_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_set_axis_node_id_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_set_axis_node_id_unpack(
    struct qpup_axis_2_set_axis_node_id_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_2_set_axis_node_id_axis_node_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_axis_node_id_axis_node_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_axis_node_id_axis_node_id_is_in_range(uint32_t value);

/**
 * Pack message Axis_2_Set_Axis_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_set_axis_state_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_set_axis_state_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Set_Axis_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_set_axis_state_unpack(
    struct qpup_axis_2_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_2_set_axis_state_axis_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_axis_state_axis_requested_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_axis_state_axis_requested_state_is_in_range(uint32_t value);

/**
 * Pack message Axis_2_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_get_encoder_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_get_encoder_estimates_unpack(
    struct qpup_axis_2_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_get_encoder_estimates_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_get_encoder_estimates_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_get_encoder_estimates_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_get_encoder_estimates_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_get_encoder_estimates_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_get_encoder_estimates_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_2_Get_Encoder_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_get_encoder_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Get_Encoder_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_get_encoder_count_unpack(
    struct qpup_axis_2_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_2_get_encoder_count_shadow_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_get_encoder_count_shadow_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_get_encoder_count_shadow_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_2_get_encoder_count_count_in_cpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_get_encoder_count_count_in_cpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_get_encoder_count_count_in_cpr_is_in_range(uint32_t value);

/**
 * Pack message Axis_2_Set_Controller_Mode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_set_controller_mode_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Set_Controller_Mode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_set_controller_mode_unpack(
    struct qpup_axis_2_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_2_set_controller_mode_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_controller_mode_control_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_controller_mode_control_mode_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_2_set_controller_mode_input_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_controller_mode_input_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_controller_mode_input_mode_is_in_range(uint32_t value);

/**
 * Pack message Axis_2_Set_Input_Pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_set_input_pos_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_set_input_pos_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Set_Input_Pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_set_input_pos_unpack(
    struct qpup_axis_2_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_set_input_pos_input_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_input_pos_input_pos_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_input_pos_input_pos_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_2_set_input_pos_vel_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_input_pos_vel_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_input_pos_vel_ff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_2_set_input_pos_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_input_pos_torque_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_input_pos_torque_ff_is_in_range(int16_t value);

/**
 * Pack message Axis_2_Set_Input_Vel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_set_input_vel_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_set_input_vel_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Set_Input_Vel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_set_input_vel_unpack(
    struct qpup_axis_2_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_set_input_vel_input_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_input_vel_input_vel_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_input_vel_input_vel_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_set_input_vel_input_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_input_vel_input_torque_ff_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_input_vel_input_torque_ff_is_in_range(float value);

/**
 * Pack message Axis_2_Set_Input_Torque.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_set_input_torque_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_set_input_torque_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Set_Input_Torque.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_set_input_torque_unpack(
    struct qpup_axis_2_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_set_input_torque_input_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_input_torque_input_torque_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_input_torque_input_torque_is_in_range(float value);

/**
 * Pack message Axis_2_Set_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_set_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_set_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Set_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_set_limits_unpack(
    struct qpup_axis_2_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_set_limits_velocity_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_limits_velocity_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_limits_velocity_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_set_limits_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_limits_current_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_limits_current_limit_is_in_range(float value);

/**
 * Pack message Axis_2_Start_Anticogging.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_start_anticogging_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_start_anticogging_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Start_Anticogging.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_start_anticogging_unpack(
    struct qpup_axis_2_start_anticogging_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_2_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_set_traj_vel_limit_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_set_traj_vel_limit_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_set_traj_vel_limit_unpack(
    struct qpup_axis_2_set_traj_vel_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_set_traj_vel_limit_traj_vel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_traj_vel_limit_traj_vel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_traj_vel_limit_traj_vel_limit_is_in_range(float value);

/**
 * Pack message Axis_2_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_set_traj_accel_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_set_traj_accel_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_set_traj_accel_limits_unpack(
    struct qpup_axis_2_set_traj_accel_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_set_traj_accel_limits_traj_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_traj_accel_limits_traj_accel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_traj_accel_limits_traj_accel_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_set_traj_accel_limits_traj_decel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_traj_accel_limits_traj_decel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_traj_accel_limits_traj_decel_limit_is_in_range(float value);

/**
 * Pack message Axis_2_Set_Traj_Inertia.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_set_traj_inertia_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_set_traj_inertia_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Set_Traj_Inertia.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_set_traj_inertia_unpack(
    struct qpup_axis_2_set_traj_inertia_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_set_traj_inertia_traj_inertia_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_traj_inertia_traj_inertia_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_traj_inertia_traj_inertia_is_in_range(float value);

/**
 * Pack message Axis_2_Get_Iq.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_get_iq_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_get_iq_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Get_Iq.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_get_iq_unpack(
    struct qpup_axis_2_get_iq_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_get_iq_iq_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_get_iq_iq_setpoint_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_get_iq_iq_setpoint_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_get_iq_iq_measured_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_get_iq_iq_measured_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_get_iq_iq_measured_is_in_range(float value);

/**
 * Pack message Axis_2_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_get_sensorless_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_get_sensorless_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_get_sensorless_estimates_unpack(
    struct qpup_axis_2_get_sensorless_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_get_sensorless_estimates_sensorless_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_get_sensorless_estimates_sensorless_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_get_sensorless_estimates_sensorless_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_get_sensorless_estimates_sensorless_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_get_sensorless_estimates_sensorless_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_get_sensorless_estimates_sensorless_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_2_Reboot.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_reboot_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_reboot_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Reboot.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_reboot_unpack(
    struct qpup_axis_2_reboot_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_2_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_get_vbus_voltage_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_get_vbus_voltage_unpack(
    struct qpup_axis_2_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_get_vbus_voltage_vbus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_get_vbus_voltage_vbus_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_get_vbus_voltage_vbus_voltage_is_in_range(float value);

/**
 * Pack message Axis_2_Clear_Errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_clear_errors_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Clear_Errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_clear_errors_unpack(
    struct qpup_axis_2_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_2_Set_Linear_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_set_linear_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_set_linear_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Set_Linear_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_set_linear_count_unpack(
    struct qpup_axis_2_set_linear_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t qpup_axis_2_set_linear_count_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_linear_count_position_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_linear_count_position_is_in_range(int32_t value);

/**
 * Pack message Axis_2_Set_Pos_Gain.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_set_pos_gain_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_set_pos_gain_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Set_Pos_Gain.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_set_pos_gain_unpack(
    struct qpup_axis_2_set_pos_gain_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_set_pos_gain_pos_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_pos_gain_pos_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_pos_gain_pos_gain_is_in_range(float value);

/**
 * Pack message Axis_2_Set_Vel_gains.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_2_set_vel_gains_pack(
    uint8_t *dst_p,
    const struct qpup_axis_2_set_vel_gains_t *src_p,
    size_t size);

/**
 * Unpack message Axis_2_Set_Vel_gains.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_2_set_vel_gains_unpack(
    struct qpup_axis_2_set_vel_gains_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_set_vel_gains_vel_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_vel_gains_vel_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_vel_gains_vel_gain_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_2_set_vel_gains_vel_integrator_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_2_set_vel_gains_vel_integrator_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_2_set_vel_gains_vel_integrator_gain_is_in_range(float value);

/**
 * Pack message Axis_3_Heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_heartbeat_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_heartbeat_unpack(
    struct qpup_axis_3_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_3_heartbeat_axis_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_heartbeat_axis_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_heartbeat_axis_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_3_heartbeat_axis_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_heartbeat_axis_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_heartbeat_axis_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_3_heartbeat_motor_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_heartbeat_motor_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_heartbeat_motor_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_3_heartbeat_encoder_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_heartbeat_encoder_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_heartbeat_encoder_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_3_heartbeat_controller_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_heartbeat_controller_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_heartbeat_controller_flags_is_in_range(uint8_t value);

/**
 * Pack message Axis_3_Estop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_estop_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_estop_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Estop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_estop_unpack(
    struct qpup_axis_3_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_3_Get_Motor_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_get_motor_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_get_motor_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Get_Motor_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_get_motor_error_unpack(
    struct qpup_axis_3_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_3_get_motor_error_motor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_get_motor_error_motor_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_get_motor_error_motor_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_3_Get_Encoder_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_get_encoder_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Get_Encoder_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_get_encoder_error_unpack(
    struct qpup_axis_3_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_3_get_encoder_error_encoder_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_get_encoder_error_encoder_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_get_encoder_error_encoder_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_3_Get_Sensorless_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_get_sensorless_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_get_sensorless_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Get_Sensorless_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_get_sensorless_error_unpack(
    struct qpup_axis_3_get_sensorless_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_3_get_sensorless_error_sensorless_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_get_sensorless_error_sensorless_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_get_sensorless_error_sensorless_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_3_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_set_axis_node_id_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_set_axis_node_id_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_set_axis_node_id_unpack(
    struct qpup_axis_3_set_axis_node_id_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_3_set_axis_node_id_axis_node_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_axis_node_id_axis_node_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_axis_node_id_axis_node_id_is_in_range(uint32_t value);

/**
 * Pack message Axis_3_Set_Axis_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_set_axis_state_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_set_axis_state_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Set_Axis_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_set_axis_state_unpack(
    struct qpup_axis_3_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_3_set_axis_state_axis_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_axis_state_axis_requested_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_axis_state_axis_requested_state_is_in_range(uint32_t value);

/**
 * Pack message Axis_3_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_get_encoder_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_get_encoder_estimates_unpack(
    struct qpup_axis_3_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_get_encoder_estimates_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_get_encoder_estimates_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_get_encoder_estimates_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_get_encoder_estimates_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_get_encoder_estimates_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_get_encoder_estimates_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_3_Get_Encoder_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_get_encoder_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Get_Encoder_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_get_encoder_count_unpack(
    struct qpup_axis_3_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_3_get_encoder_count_shadow_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_get_encoder_count_shadow_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_get_encoder_count_shadow_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_3_get_encoder_count_count_in_cpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_get_encoder_count_count_in_cpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_get_encoder_count_count_in_cpr_is_in_range(uint32_t value);

/**
 * Pack message Axis_3_Set_Controller_Mode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_set_controller_mode_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Set_Controller_Mode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_set_controller_mode_unpack(
    struct qpup_axis_3_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_3_set_controller_mode_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_controller_mode_control_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_controller_mode_control_mode_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_3_set_controller_mode_input_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_controller_mode_input_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_controller_mode_input_mode_is_in_range(uint32_t value);

/**
 * Pack message Axis_3_Set_Input_Pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_set_input_pos_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_set_input_pos_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Set_Input_Pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_set_input_pos_unpack(
    struct qpup_axis_3_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_set_input_pos_input_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_input_pos_input_pos_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_input_pos_input_pos_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_3_set_input_pos_vel_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_input_pos_vel_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_input_pos_vel_ff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_3_set_input_pos_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_input_pos_torque_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_input_pos_torque_ff_is_in_range(int16_t value);

/**
 * Pack message Axis_3_Set_Input_Vel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_set_input_vel_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_set_input_vel_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Set_Input_Vel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_set_input_vel_unpack(
    struct qpup_axis_3_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_set_input_vel_input_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_input_vel_input_vel_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_input_vel_input_vel_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_set_input_vel_input_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_input_vel_input_torque_ff_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_input_vel_input_torque_ff_is_in_range(float value);

/**
 * Pack message Axis_3_Set_Input_Torque.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_set_input_torque_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_set_input_torque_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Set_Input_Torque.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_set_input_torque_unpack(
    struct qpup_axis_3_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_set_input_torque_input_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_input_torque_input_torque_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_input_torque_input_torque_is_in_range(float value);

/**
 * Pack message Axis_3_Set_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_set_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_set_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Set_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_set_limits_unpack(
    struct qpup_axis_3_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_set_limits_velocity_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_limits_velocity_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_limits_velocity_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_set_limits_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_limits_current_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_limits_current_limit_is_in_range(float value);

/**
 * Pack message Axis_3_Start_Anticogging.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_start_anticogging_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_start_anticogging_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Start_Anticogging.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_start_anticogging_unpack(
    struct qpup_axis_3_start_anticogging_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_3_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_set_traj_vel_limit_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_set_traj_vel_limit_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_set_traj_vel_limit_unpack(
    struct qpup_axis_3_set_traj_vel_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_set_traj_vel_limit_traj_vel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_traj_vel_limit_traj_vel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_traj_vel_limit_traj_vel_limit_is_in_range(float value);

/**
 * Pack message Axis_3_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_set_traj_accel_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_set_traj_accel_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_set_traj_accel_limits_unpack(
    struct qpup_axis_3_set_traj_accel_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_set_traj_accel_limits_traj_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_traj_accel_limits_traj_accel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_traj_accel_limits_traj_accel_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_set_traj_accel_limits_traj_decel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_traj_accel_limits_traj_decel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_traj_accel_limits_traj_decel_limit_is_in_range(float value);

/**
 * Pack message Axis_3_Set_Traj_Inertia.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_set_traj_inertia_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_set_traj_inertia_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Set_Traj_Inertia.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_set_traj_inertia_unpack(
    struct qpup_axis_3_set_traj_inertia_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_set_traj_inertia_traj_inertia_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_traj_inertia_traj_inertia_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_traj_inertia_traj_inertia_is_in_range(float value);

/**
 * Pack message Axis_3_Get_Iq.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_get_iq_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_get_iq_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Get_Iq.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_get_iq_unpack(
    struct qpup_axis_3_get_iq_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_get_iq_iq_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_get_iq_iq_setpoint_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_get_iq_iq_setpoint_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_get_iq_iq_measured_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_get_iq_iq_measured_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_get_iq_iq_measured_is_in_range(float value);

/**
 * Pack message Axis_3_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_get_sensorless_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_get_sensorless_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_get_sensorless_estimates_unpack(
    struct qpup_axis_3_get_sensorless_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_get_sensorless_estimates_sensorless_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_get_sensorless_estimates_sensorless_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_get_sensorless_estimates_sensorless_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_get_sensorless_estimates_sensorless_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_get_sensorless_estimates_sensorless_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_get_sensorless_estimates_sensorless_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_3_Reboot.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_reboot_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_reboot_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Reboot.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_reboot_unpack(
    struct qpup_axis_3_reboot_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_3_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_get_vbus_voltage_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_get_vbus_voltage_unpack(
    struct qpup_axis_3_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_get_vbus_voltage_vbus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_get_vbus_voltage_vbus_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_get_vbus_voltage_vbus_voltage_is_in_range(float value);

/**
 * Pack message Axis_3_Clear_Errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_clear_errors_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Clear_Errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_clear_errors_unpack(
    struct qpup_axis_3_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_3_Set_Linear_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_set_linear_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_set_linear_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Set_Linear_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_set_linear_count_unpack(
    struct qpup_axis_3_set_linear_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t qpup_axis_3_set_linear_count_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_linear_count_position_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_linear_count_position_is_in_range(int32_t value);

/**
 * Pack message Axis_3_Set_Pos_Gain.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_set_pos_gain_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_set_pos_gain_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Set_Pos_Gain.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_set_pos_gain_unpack(
    struct qpup_axis_3_set_pos_gain_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_set_pos_gain_pos_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_pos_gain_pos_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_pos_gain_pos_gain_is_in_range(float value);

/**
 * Pack message Axis_3_Set_Vel_gains.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_3_set_vel_gains_pack(
    uint8_t *dst_p,
    const struct qpup_axis_3_set_vel_gains_t *src_p,
    size_t size);

/**
 * Unpack message Axis_3_Set_Vel_gains.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_3_set_vel_gains_unpack(
    struct qpup_axis_3_set_vel_gains_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_set_vel_gains_vel_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_vel_gains_vel_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_vel_gains_vel_gain_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_3_set_vel_gains_vel_integrator_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_3_set_vel_gains_vel_integrator_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_3_set_vel_gains_vel_integrator_gain_is_in_range(float value);

/**
 * Pack message Axis_4_Heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_heartbeat_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_heartbeat_unpack(
    struct qpup_axis_4_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_4_heartbeat_axis_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_heartbeat_axis_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_heartbeat_axis_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_4_heartbeat_axis_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_heartbeat_axis_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_heartbeat_axis_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_4_heartbeat_motor_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_heartbeat_motor_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_heartbeat_motor_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_4_heartbeat_encoder_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_heartbeat_encoder_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_heartbeat_encoder_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_4_heartbeat_controller_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_heartbeat_controller_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_heartbeat_controller_flags_is_in_range(uint8_t value);

/**
 * Pack message Axis_4_Estop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_estop_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_estop_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Estop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_estop_unpack(
    struct qpup_axis_4_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_4_Get_Motor_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_get_motor_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_get_motor_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Get_Motor_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_get_motor_error_unpack(
    struct qpup_axis_4_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_4_get_motor_error_motor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_get_motor_error_motor_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_get_motor_error_motor_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_4_Get_Encoder_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_get_encoder_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Get_Encoder_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_get_encoder_error_unpack(
    struct qpup_axis_4_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_4_get_encoder_error_encoder_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_get_encoder_error_encoder_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_get_encoder_error_encoder_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_4_Get_Sensorless_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_get_sensorless_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_get_sensorless_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Get_Sensorless_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_get_sensorless_error_unpack(
    struct qpup_axis_4_get_sensorless_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_4_get_sensorless_error_sensorless_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_get_sensorless_error_sensorless_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_get_sensorless_error_sensorless_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_4_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_set_axis_node_id_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_set_axis_node_id_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_set_axis_node_id_unpack(
    struct qpup_axis_4_set_axis_node_id_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_4_set_axis_node_id_axis_node_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_axis_node_id_axis_node_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_axis_node_id_axis_node_id_is_in_range(uint32_t value);

/**
 * Pack message Axis_4_Set_Axis_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_set_axis_state_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_set_axis_state_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Set_Axis_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_set_axis_state_unpack(
    struct qpup_axis_4_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_4_set_axis_state_axis_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_axis_state_axis_requested_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_axis_state_axis_requested_state_is_in_range(uint32_t value);

/**
 * Pack message Axis_4_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_get_encoder_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_get_encoder_estimates_unpack(
    struct qpup_axis_4_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_get_encoder_estimates_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_get_encoder_estimates_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_get_encoder_estimates_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_get_encoder_estimates_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_get_encoder_estimates_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_get_encoder_estimates_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_4_Get_Encoder_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_get_encoder_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Get_Encoder_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_get_encoder_count_unpack(
    struct qpup_axis_4_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_4_get_encoder_count_shadow_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_get_encoder_count_shadow_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_get_encoder_count_shadow_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_4_get_encoder_count_count_in_cpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_get_encoder_count_count_in_cpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_get_encoder_count_count_in_cpr_is_in_range(uint32_t value);

/**
 * Pack message Axis_4_Set_Controller_Mode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_set_controller_mode_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Set_Controller_Mode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_set_controller_mode_unpack(
    struct qpup_axis_4_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_4_set_controller_mode_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_controller_mode_control_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_controller_mode_control_mode_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_4_set_controller_mode_input_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_controller_mode_input_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_controller_mode_input_mode_is_in_range(uint32_t value);

/**
 * Pack message Axis_4_Set_Input_Pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_set_input_pos_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_set_input_pos_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Set_Input_Pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_set_input_pos_unpack(
    struct qpup_axis_4_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_set_input_pos_input_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_input_pos_input_pos_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_input_pos_input_pos_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_4_set_input_pos_vel_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_input_pos_vel_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_input_pos_vel_ff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_4_set_input_pos_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_input_pos_torque_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_input_pos_torque_ff_is_in_range(int16_t value);

/**
 * Pack message Axis_4_Set_Input_Vel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_set_input_vel_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_set_input_vel_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Set_Input_Vel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_set_input_vel_unpack(
    struct qpup_axis_4_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_set_input_vel_input_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_input_vel_input_vel_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_input_vel_input_vel_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_set_input_vel_input_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_input_vel_input_torque_ff_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_input_vel_input_torque_ff_is_in_range(float value);

/**
 * Pack message Axis_4_Set_Input_Torque.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_set_input_torque_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_set_input_torque_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Set_Input_Torque.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_set_input_torque_unpack(
    struct qpup_axis_4_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_set_input_torque_input_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_input_torque_input_torque_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_input_torque_input_torque_is_in_range(float value);

/**
 * Pack message Axis_4_Set_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_set_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_set_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Set_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_set_limits_unpack(
    struct qpup_axis_4_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_set_limits_velocity_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_limits_velocity_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_limits_velocity_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_set_limits_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_limits_current_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_limits_current_limit_is_in_range(float value);

/**
 * Pack message Axis_4_Start_Anticogging.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_start_anticogging_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_start_anticogging_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Start_Anticogging.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_start_anticogging_unpack(
    struct qpup_axis_4_start_anticogging_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_4_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_set_traj_vel_limit_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_set_traj_vel_limit_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_set_traj_vel_limit_unpack(
    struct qpup_axis_4_set_traj_vel_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_set_traj_vel_limit_traj_vel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_traj_vel_limit_traj_vel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_traj_vel_limit_traj_vel_limit_is_in_range(float value);

/**
 * Pack message Axis_4_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_set_traj_accel_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_set_traj_accel_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_set_traj_accel_limits_unpack(
    struct qpup_axis_4_set_traj_accel_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_set_traj_accel_limits_traj_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_traj_accel_limits_traj_accel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_traj_accel_limits_traj_accel_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_set_traj_accel_limits_traj_decel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_traj_accel_limits_traj_decel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_traj_accel_limits_traj_decel_limit_is_in_range(float value);

/**
 * Pack message Axis_4_Set_Traj_Inertia.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_set_traj_inertia_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_set_traj_inertia_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Set_Traj_Inertia.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_set_traj_inertia_unpack(
    struct qpup_axis_4_set_traj_inertia_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_set_traj_inertia_traj_inertia_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_traj_inertia_traj_inertia_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_traj_inertia_traj_inertia_is_in_range(float value);

/**
 * Pack message Axis_4_Get_Iq.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_get_iq_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_get_iq_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Get_Iq.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_get_iq_unpack(
    struct qpup_axis_4_get_iq_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_get_iq_iq_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_get_iq_iq_setpoint_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_get_iq_iq_setpoint_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_get_iq_iq_measured_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_get_iq_iq_measured_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_get_iq_iq_measured_is_in_range(float value);

/**
 * Pack message Axis_4_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_get_sensorless_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_get_sensorless_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_get_sensorless_estimates_unpack(
    struct qpup_axis_4_get_sensorless_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_get_sensorless_estimates_sensorless_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_get_sensorless_estimates_sensorless_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_get_sensorless_estimates_sensorless_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_get_sensorless_estimates_sensorless_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_get_sensorless_estimates_sensorless_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_get_sensorless_estimates_sensorless_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_4_Reboot.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_reboot_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_reboot_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Reboot.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_reboot_unpack(
    struct qpup_axis_4_reboot_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_4_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_get_vbus_voltage_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_get_vbus_voltage_unpack(
    struct qpup_axis_4_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_get_vbus_voltage_vbus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_get_vbus_voltage_vbus_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_get_vbus_voltage_vbus_voltage_is_in_range(float value);

/**
 * Pack message Axis_4_Clear_Errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_clear_errors_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Clear_Errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_clear_errors_unpack(
    struct qpup_axis_4_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_4_Set_Linear_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_set_linear_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_set_linear_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Set_Linear_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_set_linear_count_unpack(
    struct qpup_axis_4_set_linear_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t qpup_axis_4_set_linear_count_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_linear_count_position_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_linear_count_position_is_in_range(int32_t value);

/**
 * Pack message Axis_4_Set_Pos_Gain.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_set_pos_gain_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_set_pos_gain_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Set_Pos_Gain.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_set_pos_gain_unpack(
    struct qpup_axis_4_set_pos_gain_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_set_pos_gain_pos_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_pos_gain_pos_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_pos_gain_pos_gain_is_in_range(float value);

/**
 * Pack message Axis_4_Set_Vel_gains.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_4_set_vel_gains_pack(
    uint8_t *dst_p,
    const struct qpup_axis_4_set_vel_gains_t *src_p,
    size_t size);

/**
 * Unpack message Axis_4_Set_Vel_gains.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_4_set_vel_gains_unpack(
    struct qpup_axis_4_set_vel_gains_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_set_vel_gains_vel_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_vel_gains_vel_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_vel_gains_vel_gain_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_4_set_vel_gains_vel_integrator_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_4_set_vel_gains_vel_integrator_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_4_set_vel_gains_vel_integrator_gain_is_in_range(float value);

/**
 * Pack message Axis_5_Heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_heartbeat_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_heartbeat_unpack(
    struct qpup_axis_5_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_5_heartbeat_axis_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_heartbeat_axis_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_heartbeat_axis_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_5_heartbeat_axis_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_heartbeat_axis_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_heartbeat_axis_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_5_heartbeat_motor_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_heartbeat_motor_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_heartbeat_motor_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_5_heartbeat_encoder_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_heartbeat_encoder_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_heartbeat_encoder_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_5_heartbeat_controller_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_heartbeat_controller_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_heartbeat_controller_flags_is_in_range(uint8_t value);

/**
 * Pack message Axis_5_Estop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_estop_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_estop_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Estop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_estop_unpack(
    struct qpup_axis_5_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_5_Get_Motor_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_get_motor_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_get_motor_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Get_Motor_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_get_motor_error_unpack(
    struct qpup_axis_5_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_5_get_motor_error_motor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_get_motor_error_motor_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_get_motor_error_motor_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_5_Get_Encoder_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_get_encoder_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Get_Encoder_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_get_encoder_error_unpack(
    struct qpup_axis_5_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_5_get_encoder_error_encoder_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_get_encoder_error_encoder_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_get_encoder_error_encoder_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_5_Get_Sensorless_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_get_sensorless_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_get_sensorless_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Get_Sensorless_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_get_sensorless_error_unpack(
    struct qpup_axis_5_get_sensorless_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_5_get_sensorless_error_sensorless_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_get_sensorless_error_sensorless_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_get_sensorless_error_sensorless_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_5_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_set_axis_node_id_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_set_axis_node_id_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_set_axis_node_id_unpack(
    struct qpup_axis_5_set_axis_node_id_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_5_set_axis_node_id_axis_node_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_axis_node_id_axis_node_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_axis_node_id_axis_node_id_is_in_range(uint32_t value);

/**
 * Pack message Axis_5_Set_Axis_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_set_axis_state_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_set_axis_state_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Set_Axis_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_set_axis_state_unpack(
    struct qpup_axis_5_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_5_set_axis_state_axis_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_axis_state_axis_requested_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_axis_state_axis_requested_state_is_in_range(uint32_t value);

/**
 * Pack message Axis_5_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_get_encoder_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_get_encoder_estimates_unpack(
    struct qpup_axis_5_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_get_encoder_estimates_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_get_encoder_estimates_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_get_encoder_estimates_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_get_encoder_estimates_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_get_encoder_estimates_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_get_encoder_estimates_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_5_Get_Encoder_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_get_encoder_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Get_Encoder_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_get_encoder_count_unpack(
    struct qpup_axis_5_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_5_get_encoder_count_shadow_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_get_encoder_count_shadow_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_get_encoder_count_shadow_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_5_get_encoder_count_count_in_cpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_get_encoder_count_count_in_cpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_get_encoder_count_count_in_cpr_is_in_range(uint32_t value);

/**
 * Pack message Axis_5_Set_Controller_Mode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_set_controller_mode_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Set_Controller_Mode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_set_controller_mode_unpack(
    struct qpup_axis_5_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_5_set_controller_mode_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_controller_mode_control_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_controller_mode_control_mode_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_5_set_controller_mode_input_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_controller_mode_input_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_controller_mode_input_mode_is_in_range(uint32_t value);

/**
 * Pack message Axis_5_Set_Input_Pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_set_input_pos_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_set_input_pos_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Set_Input_Pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_set_input_pos_unpack(
    struct qpup_axis_5_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_set_input_pos_input_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_input_pos_input_pos_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_input_pos_input_pos_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_5_set_input_pos_vel_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_input_pos_vel_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_input_pos_vel_ff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_5_set_input_pos_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_input_pos_torque_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_input_pos_torque_ff_is_in_range(int16_t value);

/**
 * Pack message Axis_5_Set_Input_Vel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_set_input_vel_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_set_input_vel_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Set_Input_Vel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_set_input_vel_unpack(
    struct qpup_axis_5_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_set_input_vel_input_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_input_vel_input_vel_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_input_vel_input_vel_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_set_input_vel_input_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_input_vel_input_torque_ff_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_input_vel_input_torque_ff_is_in_range(float value);

/**
 * Pack message Axis_5_Set_Input_Torque.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_set_input_torque_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_set_input_torque_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Set_Input_Torque.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_set_input_torque_unpack(
    struct qpup_axis_5_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_set_input_torque_input_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_input_torque_input_torque_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_input_torque_input_torque_is_in_range(float value);

/**
 * Pack message Axis_5_Set_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_set_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_set_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Set_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_set_limits_unpack(
    struct qpup_axis_5_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_set_limits_velocity_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_limits_velocity_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_limits_velocity_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_set_limits_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_limits_current_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_limits_current_limit_is_in_range(float value);

/**
 * Pack message Axis_5_Start_Anticogging.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_start_anticogging_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_start_anticogging_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Start_Anticogging.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_start_anticogging_unpack(
    struct qpup_axis_5_start_anticogging_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_5_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_set_traj_vel_limit_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_set_traj_vel_limit_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_set_traj_vel_limit_unpack(
    struct qpup_axis_5_set_traj_vel_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_set_traj_vel_limit_traj_vel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_traj_vel_limit_traj_vel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_traj_vel_limit_traj_vel_limit_is_in_range(float value);

/**
 * Pack message Axis_5_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_set_traj_accel_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_set_traj_accel_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_set_traj_accel_limits_unpack(
    struct qpup_axis_5_set_traj_accel_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_set_traj_accel_limits_traj_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_traj_accel_limits_traj_accel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_traj_accel_limits_traj_accel_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_set_traj_accel_limits_traj_decel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_traj_accel_limits_traj_decel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_traj_accel_limits_traj_decel_limit_is_in_range(float value);

/**
 * Pack message Axis_5_Set_Traj_Inertia.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_set_traj_inertia_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_set_traj_inertia_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Set_Traj_Inertia.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_set_traj_inertia_unpack(
    struct qpup_axis_5_set_traj_inertia_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_set_traj_inertia_traj_inertia_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_traj_inertia_traj_inertia_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_traj_inertia_traj_inertia_is_in_range(float value);

/**
 * Pack message Axis_5_Get_Iq.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_get_iq_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_get_iq_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Get_Iq.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_get_iq_unpack(
    struct qpup_axis_5_get_iq_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_get_iq_iq_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_get_iq_iq_setpoint_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_get_iq_iq_setpoint_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_get_iq_iq_measured_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_get_iq_iq_measured_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_get_iq_iq_measured_is_in_range(float value);

/**
 * Pack message Axis_5_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_get_sensorless_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_get_sensorless_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_get_sensorless_estimates_unpack(
    struct qpup_axis_5_get_sensorless_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_get_sensorless_estimates_sensorless_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_get_sensorless_estimates_sensorless_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_get_sensorless_estimates_sensorless_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_get_sensorless_estimates_sensorless_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_get_sensorless_estimates_sensorless_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_get_sensorless_estimates_sensorless_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_5_Reboot.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_reboot_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_reboot_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Reboot.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_reboot_unpack(
    struct qpup_axis_5_reboot_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_5_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_get_vbus_voltage_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_get_vbus_voltage_unpack(
    struct qpup_axis_5_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_get_vbus_voltage_vbus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_get_vbus_voltage_vbus_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_get_vbus_voltage_vbus_voltage_is_in_range(float value);

/**
 * Pack message Axis_5_Clear_Errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_clear_errors_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Clear_Errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_clear_errors_unpack(
    struct qpup_axis_5_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_5_Set_Linear_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_set_linear_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_set_linear_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Set_Linear_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_set_linear_count_unpack(
    struct qpup_axis_5_set_linear_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t qpup_axis_5_set_linear_count_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_linear_count_position_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_linear_count_position_is_in_range(int32_t value);

/**
 * Pack message Axis_5_Set_Pos_Gain.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_set_pos_gain_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_set_pos_gain_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Set_Pos_Gain.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_set_pos_gain_unpack(
    struct qpup_axis_5_set_pos_gain_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_set_pos_gain_pos_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_pos_gain_pos_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_pos_gain_pos_gain_is_in_range(float value);

/**
 * Pack message Axis_5_Set_Vel_gains.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_5_set_vel_gains_pack(
    uint8_t *dst_p,
    const struct qpup_axis_5_set_vel_gains_t *src_p,
    size_t size);

/**
 * Unpack message Axis_5_Set_Vel_gains.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_5_set_vel_gains_unpack(
    struct qpup_axis_5_set_vel_gains_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_set_vel_gains_vel_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_vel_gains_vel_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_vel_gains_vel_gain_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_5_set_vel_gains_vel_integrator_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_5_set_vel_gains_vel_integrator_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_5_set_vel_gains_vel_integrator_gain_is_in_range(float value);

/**
 * Pack message Axis_6_Heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_heartbeat_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_heartbeat_unpack(
    struct qpup_axis_6_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_6_heartbeat_axis_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_heartbeat_axis_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_heartbeat_axis_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_6_heartbeat_axis_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_heartbeat_axis_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_heartbeat_axis_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_6_heartbeat_motor_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_heartbeat_motor_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_heartbeat_motor_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_6_heartbeat_encoder_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_heartbeat_encoder_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_heartbeat_encoder_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_6_heartbeat_controller_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_heartbeat_controller_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_heartbeat_controller_flags_is_in_range(uint8_t value);

/**
 * Pack message Axis_6_Estop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_estop_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_estop_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Estop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_estop_unpack(
    struct qpup_axis_6_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_6_Get_Motor_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_get_motor_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_get_motor_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Get_Motor_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_get_motor_error_unpack(
    struct qpup_axis_6_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_6_get_motor_error_motor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_get_motor_error_motor_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_get_motor_error_motor_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_6_Get_Encoder_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_get_encoder_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Get_Encoder_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_get_encoder_error_unpack(
    struct qpup_axis_6_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_6_get_encoder_error_encoder_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_get_encoder_error_encoder_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_get_encoder_error_encoder_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_6_Get_Sensorless_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_get_sensorless_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_get_sensorless_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Get_Sensorless_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_get_sensorless_error_unpack(
    struct qpup_axis_6_get_sensorless_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_6_get_sensorless_error_sensorless_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_get_sensorless_error_sensorless_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_get_sensorless_error_sensorless_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_6_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_set_axis_node_id_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_set_axis_node_id_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_set_axis_node_id_unpack(
    struct qpup_axis_6_set_axis_node_id_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_6_set_axis_node_id_axis_node_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_axis_node_id_axis_node_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_axis_node_id_axis_node_id_is_in_range(uint32_t value);

/**
 * Pack message Axis_6_Set_Axis_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_set_axis_state_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_set_axis_state_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Set_Axis_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_set_axis_state_unpack(
    struct qpup_axis_6_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_6_set_axis_state_axis_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_axis_state_axis_requested_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_axis_state_axis_requested_state_is_in_range(uint32_t value);

/**
 * Pack message Axis_6_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_get_encoder_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_get_encoder_estimates_unpack(
    struct qpup_axis_6_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_get_encoder_estimates_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_get_encoder_estimates_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_get_encoder_estimates_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_get_encoder_estimates_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_get_encoder_estimates_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_get_encoder_estimates_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_6_Get_Encoder_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_get_encoder_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Get_Encoder_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_get_encoder_count_unpack(
    struct qpup_axis_6_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_6_get_encoder_count_shadow_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_get_encoder_count_shadow_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_get_encoder_count_shadow_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_6_get_encoder_count_count_in_cpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_get_encoder_count_count_in_cpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_get_encoder_count_count_in_cpr_is_in_range(uint32_t value);

/**
 * Pack message Axis_6_Set_Controller_Mode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_set_controller_mode_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Set_Controller_Mode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_set_controller_mode_unpack(
    struct qpup_axis_6_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_6_set_controller_mode_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_controller_mode_control_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_controller_mode_control_mode_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_6_set_controller_mode_input_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_controller_mode_input_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_controller_mode_input_mode_is_in_range(uint32_t value);

/**
 * Pack message Axis_6_Set_Input_Pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_set_input_pos_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_set_input_pos_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Set_Input_Pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_set_input_pos_unpack(
    struct qpup_axis_6_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_set_input_pos_input_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_input_pos_input_pos_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_input_pos_input_pos_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_6_set_input_pos_vel_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_input_pos_vel_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_input_pos_vel_ff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_6_set_input_pos_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_input_pos_torque_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_input_pos_torque_ff_is_in_range(int16_t value);

/**
 * Pack message Axis_6_Set_Input_Vel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_set_input_vel_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_set_input_vel_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Set_Input_Vel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_set_input_vel_unpack(
    struct qpup_axis_6_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_set_input_vel_input_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_input_vel_input_vel_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_input_vel_input_vel_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_set_input_vel_input_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_input_vel_input_torque_ff_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_input_vel_input_torque_ff_is_in_range(float value);

/**
 * Pack message Axis_6_Set_Input_Torque.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_set_input_torque_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_set_input_torque_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Set_Input_Torque.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_set_input_torque_unpack(
    struct qpup_axis_6_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_set_input_torque_input_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_input_torque_input_torque_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_input_torque_input_torque_is_in_range(float value);

/**
 * Pack message Axis_6_Set_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_set_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_set_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Set_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_set_limits_unpack(
    struct qpup_axis_6_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_set_limits_velocity_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_limits_velocity_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_limits_velocity_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_set_limits_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_limits_current_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_limits_current_limit_is_in_range(float value);

/**
 * Pack message Axis_6_Start_Anticogging.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_start_anticogging_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_start_anticogging_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Start_Anticogging.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_start_anticogging_unpack(
    struct qpup_axis_6_start_anticogging_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_6_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_set_traj_vel_limit_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_set_traj_vel_limit_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_set_traj_vel_limit_unpack(
    struct qpup_axis_6_set_traj_vel_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_set_traj_vel_limit_traj_vel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_traj_vel_limit_traj_vel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_traj_vel_limit_traj_vel_limit_is_in_range(float value);

/**
 * Pack message Axis_6_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_set_traj_accel_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_set_traj_accel_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_set_traj_accel_limits_unpack(
    struct qpup_axis_6_set_traj_accel_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_set_traj_accel_limits_traj_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_traj_accel_limits_traj_accel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_traj_accel_limits_traj_accel_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_set_traj_accel_limits_traj_decel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_traj_accel_limits_traj_decel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_traj_accel_limits_traj_decel_limit_is_in_range(float value);

/**
 * Pack message Axis_6_Set_Traj_Inertia.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_set_traj_inertia_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_set_traj_inertia_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Set_Traj_Inertia.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_set_traj_inertia_unpack(
    struct qpup_axis_6_set_traj_inertia_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_set_traj_inertia_traj_inertia_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_traj_inertia_traj_inertia_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_traj_inertia_traj_inertia_is_in_range(float value);

/**
 * Pack message Axis_6_Get_Iq.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_get_iq_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_get_iq_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Get_Iq.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_get_iq_unpack(
    struct qpup_axis_6_get_iq_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_get_iq_iq_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_get_iq_iq_setpoint_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_get_iq_iq_setpoint_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_get_iq_iq_measured_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_get_iq_iq_measured_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_get_iq_iq_measured_is_in_range(float value);

/**
 * Pack message Axis_6_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_get_sensorless_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_get_sensorless_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_get_sensorless_estimates_unpack(
    struct qpup_axis_6_get_sensorless_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_get_sensorless_estimates_sensorless_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_get_sensorless_estimates_sensorless_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_get_sensorless_estimates_sensorless_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_get_sensorless_estimates_sensorless_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_get_sensorless_estimates_sensorless_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_get_sensorless_estimates_sensorless_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_6_Reboot.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_reboot_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_reboot_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Reboot.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_reboot_unpack(
    struct qpup_axis_6_reboot_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_6_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_get_vbus_voltage_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_get_vbus_voltage_unpack(
    struct qpup_axis_6_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_get_vbus_voltage_vbus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_get_vbus_voltage_vbus_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_get_vbus_voltage_vbus_voltage_is_in_range(float value);

/**
 * Pack message Axis_6_Clear_Errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_clear_errors_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Clear_Errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_clear_errors_unpack(
    struct qpup_axis_6_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_6_Set_Linear_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_set_linear_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_set_linear_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Set_Linear_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_set_linear_count_unpack(
    struct qpup_axis_6_set_linear_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t qpup_axis_6_set_linear_count_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_linear_count_position_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_linear_count_position_is_in_range(int32_t value);

/**
 * Pack message Axis_6_Set_Pos_Gain.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_set_pos_gain_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_set_pos_gain_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Set_Pos_Gain.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_set_pos_gain_unpack(
    struct qpup_axis_6_set_pos_gain_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_set_pos_gain_pos_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_pos_gain_pos_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_pos_gain_pos_gain_is_in_range(float value);

/**
 * Pack message Axis_6_Set_Vel_gains.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_6_set_vel_gains_pack(
    uint8_t *dst_p,
    const struct qpup_axis_6_set_vel_gains_t *src_p,
    size_t size);

/**
 * Unpack message Axis_6_Set_Vel_gains.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_6_set_vel_gains_unpack(
    struct qpup_axis_6_set_vel_gains_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_set_vel_gains_vel_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_vel_gains_vel_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_vel_gains_vel_gain_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_6_set_vel_gains_vel_integrator_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_6_set_vel_gains_vel_integrator_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_6_set_vel_gains_vel_integrator_gain_is_in_range(float value);

/**
 * Pack message Axis_7_Heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_heartbeat_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_heartbeat_unpack(
    struct qpup_axis_7_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_7_heartbeat_axis_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_heartbeat_axis_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_heartbeat_axis_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_7_heartbeat_axis_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_heartbeat_axis_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_heartbeat_axis_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_7_heartbeat_motor_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_heartbeat_motor_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_heartbeat_motor_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_7_heartbeat_encoder_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_heartbeat_encoder_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_heartbeat_encoder_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_7_heartbeat_controller_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_heartbeat_controller_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_heartbeat_controller_flags_is_in_range(uint8_t value);

/**
 * Pack message Axis_7_Estop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_estop_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_estop_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Estop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_estop_unpack(
    struct qpup_axis_7_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_7_Get_Motor_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_get_motor_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_get_motor_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Get_Motor_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_get_motor_error_unpack(
    struct qpup_axis_7_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_7_get_motor_error_motor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_get_motor_error_motor_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_get_motor_error_motor_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_7_Get_Encoder_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_get_encoder_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Get_Encoder_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_get_encoder_error_unpack(
    struct qpup_axis_7_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_7_get_encoder_error_encoder_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_get_encoder_error_encoder_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_get_encoder_error_encoder_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_7_Get_Sensorless_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_get_sensorless_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_get_sensorless_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Get_Sensorless_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_get_sensorless_error_unpack(
    struct qpup_axis_7_get_sensorless_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_7_get_sensorless_error_sensorless_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_get_sensorless_error_sensorless_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_get_sensorless_error_sensorless_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_7_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_set_axis_node_id_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_set_axis_node_id_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_set_axis_node_id_unpack(
    struct qpup_axis_7_set_axis_node_id_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_7_set_axis_node_id_axis_node_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_axis_node_id_axis_node_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_axis_node_id_axis_node_id_is_in_range(uint32_t value);

/**
 * Pack message Axis_7_Set_Axis_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_set_axis_state_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_set_axis_state_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Set_Axis_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_set_axis_state_unpack(
    struct qpup_axis_7_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_7_set_axis_state_axis_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_axis_state_axis_requested_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_axis_state_axis_requested_state_is_in_range(uint32_t value);

/**
 * Pack message Axis_7_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_get_encoder_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_get_encoder_estimates_unpack(
    struct qpup_axis_7_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_get_encoder_estimates_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_get_encoder_estimates_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_get_encoder_estimates_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_get_encoder_estimates_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_get_encoder_estimates_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_get_encoder_estimates_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_7_Get_Encoder_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_get_encoder_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Get_Encoder_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_get_encoder_count_unpack(
    struct qpup_axis_7_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_7_get_encoder_count_shadow_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_get_encoder_count_shadow_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_get_encoder_count_shadow_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_7_get_encoder_count_count_in_cpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_get_encoder_count_count_in_cpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_get_encoder_count_count_in_cpr_is_in_range(uint32_t value);

/**
 * Pack message Axis_7_Set_Controller_Mode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_set_controller_mode_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Set_Controller_Mode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_set_controller_mode_unpack(
    struct qpup_axis_7_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_7_set_controller_mode_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_controller_mode_control_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_controller_mode_control_mode_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_7_set_controller_mode_input_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_controller_mode_input_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_controller_mode_input_mode_is_in_range(uint32_t value);

/**
 * Pack message Axis_7_Set_Input_Pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_set_input_pos_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_set_input_pos_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Set_Input_Pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_set_input_pos_unpack(
    struct qpup_axis_7_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_set_input_pos_input_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_input_pos_input_pos_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_input_pos_input_pos_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_7_set_input_pos_vel_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_input_pos_vel_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_input_pos_vel_ff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_7_set_input_pos_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_input_pos_torque_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_input_pos_torque_ff_is_in_range(int16_t value);

/**
 * Pack message Axis_7_Set_Input_Vel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_set_input_vel_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_set_input_vel_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Set_Input_Vel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_set_input_vel_unpack(
    struct qpup_axis_7_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_set_input_vel_input_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_input_vel_input_vel_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_input_vel_input_vel_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_set_input_vel_input_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_input_vel_input_torque_ff_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_input_vel_input_torque_ff_is_in_range(float value);

/**
 * Pack message Axis_7_Set_Input_Torque.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_set_input_torque_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_set_input_torque_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Set_Input_Torque.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_set_input_torque_unpack(
    struct qpup_axis_7_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_set_input_torque_input_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_input_torque_input_torque_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_input_torque_input_torque_is_in_range(float value);

/**
 * Pack message Axis_7_Set_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_set_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_set_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Set_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_set_limits_unpack(
    struct qpup_axis_7_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_set_limits_velocity_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_limits_velocity_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_limits_velocity_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_set_limits_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_limits_current_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_limits_current_limit_is_in_range(float value);

/**
 * Pack message Axis_7_Start_Anticogging.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_start_anticogging_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_start_anticogging_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Start_Anticogging.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_start_anticogging_unpack(
    struct qpup_axis_7_start_anticogging_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_7_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_set_traj_vel_limit_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_set_traj_vel_limit_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_set_traj_vel_limit_unpack(
    struct qpup_axis_7_set_traj_vel_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_set_traj_vel_limit_traj_vel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_traj_vel_limit_traj_vel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_traj_vel_limit_traj_vel_limit_is_in_range(float value);

/**
 * Pack message Axis_7_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_set_traj_accel_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_set_traj_accel_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_set_traj_accel_limits_unpack(
    struct qpup_axis_7_set_traj_accel_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_set_traj_accel_limits_traj_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_traj_accel_limits_traj_accel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_traj_accel_limits_traj_accel_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_set_traj_accel_limits_traj_decel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_traj_accel_limits_traj_decel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_traj_accel_limits_traj_decel_limit_is_in_range(float value);

/**
 * Pack message Axis_7_Set_Traj_Inertia.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_set_traj_inertia_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_set_traj_inertia_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Set_Traj_Inertia.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_set_traj_inertia_unpack(
    struct qpup_axis_7_set_traj_inertia_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_set_traj_inertia_traj_inertia_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_traj_inertia_traj_inertia_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_traj_inertia_traj_inertia_is_in_range(float value);

/**
 * Pack message Axis_7_Get_Iq.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_get_iq_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_get_iq_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Get_Iq.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_get_iq_unpack(
    struct qpup_axis_7_get_iq_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_get_iq_iq_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_get_iq_iq_setpoint_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_get_iq_iq_setpoint_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_get_iq_iq_measured_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_get_iq_iq_measured_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_get_iq_iq_measured_is_in_range(float value);

/**
 * Pack message Axis_7_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_get_sensorless_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_get_sensorless_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_get_sensorless_estimates_unpack(
    struct qpup_axis_7_get_sensorless_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_get_sensorless_estimates_sensorless_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_get_sensorless_estimates_sensorless_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_get_sensorless_estimates_sensorless_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_get_sensorless_estimates_sensorless_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_get_sensorless_estimates_sensorless_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_get_sensorless_estimates_sensorless_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_7_Reboot.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_reboot_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_reboot_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Reboot.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_reboot_unpack(
    struct qpup_axis_7_reboot_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_7_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_get_vbus_voltage_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_get_vbus_voltage_unpack(
    struct qpup_axis_7_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_get_vbus_voltage_vbus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_get_vbus_voltage_vbus_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_get_vbus_voltage_vbus_voltage_is_in_range(float value);

/**
 * Pack message Axis_7_Clear_Errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_clear_errors_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Clear_Errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_clear_errors_unpack(
    struct qpup_axis_7_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_7_Set_Linear_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_set_linear_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_set_linear_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Set_Linear_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_set_linear_count_unpack(
    struct qpup_axis_7_set_linear_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t qpup_axis_7_set_linear_count_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_linear_count_position_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_linear_count_position_is_in_range(int32_t value);

/**
 * Pack message Axis_7_Set_Pos_Gain.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_set_pos_gain_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_set_pos_gain_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Set_Pos_Gain.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_set_pos_gain_unpack(
    struct qpup_axis_7_set_pos_gain_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_set_pos_gain_pos_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_pos_gain_pos_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_pos_gain_pos_gain_is_in_range(float value);

/**
 * Pack message Axis_7_Set_Vel_gains.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_7_set_vel_gains_pack(
    uint8_t *dst_p,
    const struct qpup_axis_7_set_vel_gains_t *src_p,
    size_t size);

/**
 * Unpack message Axis_7_Set_Vel_gains.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_7_set_vel_gains_unpack(
    struct qpup_axis_7_set_vel_gains_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_set_vel_gains_vel_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_vel_gains_vel_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_vel_gains_vel_gain_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_7_set_vel_gains_vel_integrator_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_7_set_vel_gains_vel_integrator_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_7_set_vel_gains_vel_integrator_gain_is_in_range(float value);

/**
 * Pack message Axis_8_Heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_heartbeat_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_heartbeat_unpack(
    struct qpup_axis_8_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_8_heartbeat_axis_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_heartbeat_axis_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_heartbeat_axis_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_8_heartbeat_axis_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_heartbeat_axis_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_heartbeat_axis_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_8_heartbeat_motor_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_heartbeat_motor_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_heartbeat_motor_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_8_heartbeat_encoder_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_heartbeat_encoder_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_heartbeat_encoder_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_8_heartbeat_controller_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_heartbeat_controller_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_heartbeat_controller_flags_is_in_range(uint8_t value);

/**
 * Pack message Axis_8_Estop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_estop_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_estop_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Estop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_estop_unpack(
    struct qpup_axis_8_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_8_Get_Motor_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_get_motor_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_get_motor_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Get_Motor_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_get_motor_error_unpack(
    struct qpup_axis_8_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_8_get_motor_error_motor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_get_motor_error_motor_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_get_motor_error_motor_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_8_Get_Encoder_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_get_encoder_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Get_Encoder_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_get_encoder_error_unpack(
    struct qpup_axis_8_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_8_get_encoder_error_encoder_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_get_encoder_error_encoder_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_get_encoder_error_encoder_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_8_Get_Sensorless_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_get_sensorless_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_get_sensorless_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Get_Sensorless_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_get_sensorless_error_unpack(
    struct qpup_axis_8_get_sensorless_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_8_get_sensorless_error_sensorless_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_get_sensorless_error_sensorless_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_get_sensorless_error_sensorless_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_8_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_set_axis_node_id_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_set_axis_node_id_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_set_axis_node_id_unpack(
    struct qpup_axis_8_set_axis_node_id_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_8_set_axis_node_id_axis_node_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_axis_node_id_axis_node_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_axis_node_id_axis_node_id_is_in_range(uint32_t value);

/**
 * Pack message Axis_8_Set_Axis_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_set_axis_state_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_set_axis_state_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Set_Axis_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_set_axis_state_unpack(
    struct qpup_axis_8_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_8_set_axis_state_axis_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_axis_state_axis_requested_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_axis_state_axis_requested_state_is_in_range(uint32_t value);

/**
 * Pack message Axis_8_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_get_encoder_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_get_encoder_estimates_unpack(
    struct qpup_axis_8_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_get_encoder_estimates_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_get_encoder_estimates_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_get_encoder_estimates_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_get_encoder_estimates_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_get_encoder_estimates_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_get_encoder_estimates_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_8_Get_Encoder_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_get_encoder_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Get_Encoder_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_get_encoder_count_unpack(
    struct qpup_axis_8_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_8_get_encoder_count_shadow_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_get_encoder_count_shadow_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_get_encoder_count_shadow_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_8_get_encoder_count_count_in_cpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_get_encoder_count_count_in_cpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_get_encoder_count_count_in_cpr_is_in_range(uint32_t value);

/**
 * Pack message Axis_8_Set_Controller_Mode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_set_controller_mode_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Set_Controller_Mode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_set_controller_mode_unpack(
    struct qpup_axis_8_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_8_set_controller_mode_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_controller_mode_control_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_controller_mode_control_mode_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_8_set_controller_mode_input_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_controller_mode_input_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_controller_mode_input_mode_is_in_range(uint32_t value);

/**
 * Pack message Axis_8_Set_Input_Pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_set_input_pos_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_set_input_pos_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Set_Input_Pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_set_input_pos_unpack(
    struct qpup_axis_8_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_set_input_pos_input_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_input_pos_input_pos_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_input_pos_input_pos_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_8_set_input_pos_vel_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_input_pos_vel_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_input_pos_vel_ff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_8_set_input_pos_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_input_pos_torque_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_input_pos_torque_ff_is_in_range(int16_t value);

/**
 * Pack message Axis_8_Set_Input_Vel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_set_input_vel_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_set_input_vel_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Set_Input_Vel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_set_input_vel_unpack(
    struct qpup_axis_8_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_set_input_vel_input_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_input_vel_input_vel_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_input_vel_input_vel_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_set_input_vel_input_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_input_vel_input_torque_ff_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_input_vel_input_torque_ff_is_in_range(float value);

/**
 * Pack message Axis_8_Set_Input_Torque.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_set_input_torque_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_set_input_torque_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Set_Input_Torque.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_set_input_torque_unpack(
    struct qpup_axis_8_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_set_input_torque_input_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_input_torque_input_torque_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_input_torque_input_torque_is_in_range(float value);

/**
 * Pack message Axis_8_Set_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_set_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_set_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Set_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_set_limits_unpack(
    struct qpup_axis_8_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_set_limits_velocity_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_limits_velocity_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_limits_velocity_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_set_limits_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_limits_current_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_limits_current_limit_is_in_range(float value);

/**
 * Pack message Axis_8_Start_Anticogging.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_start_anticogging_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_start_anticogging_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Start_Anticogging.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_start_anticogging_unpack(
    struct qpup_axis_8_start_anticogging_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_8_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_set_traj_vel_limit_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_set_traj_vel_limit_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_set_traj_vel_limit_unpack(
    struct qpup_axis_8_set_traj_vel_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_set_traj_vel_limit_traj_vel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_traj_vel_limit_traj_vel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_traj_vel_limit_traj_vel_limit_is_in_range(float value);

/**
 * Pack message Axis_8_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_set_traj_accel_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_set_traj_accel_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_set_traj_accel_limits_unpack(
    struct qpup_axis_8_set_traj_accel_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_set_traj_accel_limits_traj_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_traj_accel_limits_traj_accel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_traj_accel_limits_traj_accel_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_set_traj_accel_limits_traj_decel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_traj_accel_limits_traj_decel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_traj_accel_limits_traj_decel_limit_is_in_range(float value);

/**
 * Pack message Axis_8_Set_Traj_Inertia.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_set_traj_inertia_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_set_traj_inertia_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Set_Traj_Inertia.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_set_traj_inertia_unpack(
    struct qpup_axis_8_set_traj_inertia_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_set_traj_inertia_traj_inertia_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_traj_inertia_traj_inertia_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_traj_inertia_traj_inertia_is_in_range(float value);

/**
 * Pack message Axis_8_Get_Iq.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_get_iq_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_get_iq_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Get_Iq.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_get_iq_unpack(
    struct qpup_axis_8_get_iq_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_get_iq_iq_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_get_iq_iq_setpoint_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_get_iq_iq_setpoint_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_get_iq_iq_measured_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_get_iq_iq_measured_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_get_iq_iq_measured_is_in_range(float value);

/**
 * Pack message Axis_8_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_get_sensorless_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_get_sensorless_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_get_sensorless_estimates_unpack(
    struct qpup_axis_8_get_sensorless_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_get_sensorless_estimates_sensorless_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_get_sensorless_estimates_sensorless_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_get_sensorless_estimates_sensorless_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_get_sensorless_estimates_sensorless_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_get_sensorless_estimates_sensorless_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_get_sensorless_estimates_sensorless_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_8_Reboot.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_reboot_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_reboot_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Reboot.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_reboot_unpack(
    struct qpup_axis_8_reboot_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_8_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_get_vbus_voltage_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_get_vbus_voltage_unpack(
    struct qpup_axis_8_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_get_vbus_voltage_vbus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_get_vbus_voltage_vbus_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_get_vbus_voltage_vbus_voltage_is_in_range(float value);

/**
 * Pack message Axis_8_Clear_Errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_clear_errors_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Clear_Errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_clear_errors_unpack(
    struct qpup_axis_8_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_8_Set_Linear_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_set_linear_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_set_linear_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Set_Linear_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_set_linear_count_unpack(
    struct qpup_axis_8_set_linear_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t qpup_axis_8_set_linear_count_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_linear_count_position_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_linear_count_position_is_in_range(int32_t value);

/**
 * Pack message Axis_8_Set_Pos_Gain.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_set_pos_gain_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_set_pos_gain_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Set_Pos_Gain.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_set_pos_gain_unpack(
    struct qpup_axis_8_set_pos_gain_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_set_pos_gain_pos_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_pos_gain_pos_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_pos_gain_pos_gain_is_in_range(float value);

/**
 * Pack message Axis_8_Set_Vel_gains.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_8_set_vel_gains_pack(
    uint8_t *dst_p,
    const struct qpup_axis_8_set_vel_gains_t *src_p,
    size_t size);

/**
 * Unpack message Axis_8_Set_Vel_gains.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_8_set_vel_gains_unpack(
    struct qpup_axis_8_set_vel_gains_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_set_vel_gains_vel_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_vel_gains_vel_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_vel_gains_vel_gain_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_8_set_vel_gains_vel_integrator_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_8_set_vel_gains_vel_integrator_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_8_set_vel_gains_vel_integrator_gain_is_in_range(float value);

/**
 * Pack message Axis_9_Heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_heartbeat_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_heartbeat_unpack(
    struct qpup_axis_9_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_9_heartbeat_axis_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_heartbeat_axis_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_heartbeat_axis_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_9_heartbeat_axis_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_heartbeat_axis_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_heartbeat_axis_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_9_heartbeat_motor_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_heartbeat_motor_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_heartbeat_motor_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_9_heartbeat_encoder_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_heartbeat_encoder_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_heartbeat_encoder_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_9_heartbeat_controller_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_heartbeat_controller_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_heartbeat_controller_flags_is_in_range(uint8_t value);

/**
 * Pack message Axis_9_Estop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_estop_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_estop_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Estop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_estop_unpack(
    struct qpup_axis_9_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_9_Get_Motor_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_get_motor_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_get_motor_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Get_Motor_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_get_motor_error_unpack(
    struct qpup_axis_9_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_9_get_motor_error_motor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_get_motor_error_motor_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_get_motor_error_motor_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_9_Get_Encoder_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_get_encoder_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Get_Encoder_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_get_encoder_error_unpack(
    struct qpup_axis_9_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_9_get_encoder_error_encoder_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_get_encoder_error_encoder_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_get_encoder_error_encoder_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_9_Get_Sensorless_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_get_sensorless_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_get_sensorless_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Get_Sensorless_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_get_sensorless_error_unpack(
    struct qpup_axis_9_get_sensorless_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_9_get_sensorless_error_sensorless_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_get_sensorless_error_sensorless_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_get_sensorless_error_sensorless_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_9_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_set_axis_node_id_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_set_axis_node_id_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_set_axis_node_id_unpack(
    struct qpup_axis_9_set_axis_node_id_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_9_set_axis_node_id_axis_node_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_axis_node_id_axis_node_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_axis_node_id_axis_node_id_is_in_range(uint32_t value);

/**
 * Pack message Axis_9_Set_Axis_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_set_axis_state_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_set_axis_state_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Set_Axis_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_set_axis_state_unpack(
    struct qpup_axis_9_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_9_set_axis_state_axis_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_axis_state_axis_requested_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_axis_state_axis_requested_state_is_in_range(uint32_t value);

/**
 * Pack message Axis_9_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_get_encoder_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_get_encoder_estimates_unpack(
    struct qpup_axis_9_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_get_encoder_estimates_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_get_encoder_estimates_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_get_encoder_estimates_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_get_encoder_estimates_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_get_encoder_estimates_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_get_encoder_estimates_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_9_Get_Encoder_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_get_encoder_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Get_Encoder_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_get_encoder_count_unpack(
    struct qpup_axis_9_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_9_get_encoder_count_shadow_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_get_encoder_count_shadow_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_get_encoder_count_shadow_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_9_get_encoder_count_count_in_cpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_get_encoder_count_count_in_cpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_get_encoder_count_count_in_cpr_is_in_range(uint32_t value);

/**
 * Pack message Axis_9_Set_Controller_Mode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_set_controller_mode_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Set_Controller_Mode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_set_controller_mode_unpack(
    struct qpup_axis_9_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_9_set_controller_mode_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_controller_mode_control_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_controller_mode_control_mode_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_9_set_controller_mode_input_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_controller_mode_input_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_controller_mode_input_mode_is_in_range(uint32_t value);

/**
 * Pack message Axis_9_Set_Input_Pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_set_input_pos_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_set_input_pos_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Set_Input_Pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_set_input_pos_unpack(
    struct qpup_axis_9_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_set_input_pos_input_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_input_pos_input_pos_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_input_pos_input_pos_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_9_set_input_pos_vel_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_input_pos_vel_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_input_pos_vel_ff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_9_set_input_pos_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_input_pos_torque_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_input_pos_torque_ff_is_in_range(int16_t value);

/**
 * Pack message Axis_9_Set_Input_Vel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_set_input_vel_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_set_input_vel_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Set_Input_Vel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_set_input_vel_unpack(
    struct qpup_axis_9_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_set_input_vel_input_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_input_vel_input_vel_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_input_vel_input_vel_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_set_input_vel_input_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_input_vel_input_torque_ff_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_input_vel_input_torque_ff_is_in_range(float value);

/**
 * Pack message Axis_9_Set_Input_Torque.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_set_input_torque_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_set_input_torque_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Set_Input_Torque.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_set_input_torque_unpack(
    struct qpup_axis_9_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_set_input_torque_input_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_input_torque_input_torque_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_input_torque_input_torque_is_in_range(float value);

/**
 * Pack message Axis_9_Set_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_set_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_set_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Set_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_set_limits_unpack(
    struct qpup_axis_9_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_set_limits_velocity_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_limits_velocity_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_limits_velocity_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_set_limits_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_limits_current_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_limits_current_limit_is_in_range(float value);

/**
 * Pack message Axis_9_Start_Anticogging.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_start_anticogging_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_start_anticogging_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Start_Anticogging.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_start_anticogging_unpack(
    struct qpup_axis_9_start_anticogging_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_9_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_set_traj_vel_limit_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_set_traj_vel_limit_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_set_traj_vel_limit_unpack(
    struct qpup_axis_9_set_traj_vel_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_set_traj_vel_limit_traj_vel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_traj_vel_limit_traj_vel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_traj_vel_limit_traj_vel_limit_is_in_range(float value);

/**
 * Pack message Axis_9_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_set_traj_accel_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_set_traj_accel_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_set_traj_accel_limits_unpack(
    struct qpup_axis_9_set_traj_accel_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_set_traj_accel_limits_traj_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_traj_accel_limits_traj_accel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_traj_accel_limits_traj_accel_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_set_traj_accel_limits_traj_decel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_traj_accel_limits_traj_decel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_traj_accel_limits_traj_decel_limit_is_in_range(float value);

/**
 * Pack message Axis_9_Set_Traj_Inertia.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_set_traj_inertia_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_set_traj_inertia_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Set_Traj_Inertia.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_set_traj_inertia_unpack(
    struct qpup_axis_9_set_traj_inertia_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_set_traj_inertia_traj_inertia_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_traj_inertia_traj_inertia_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_traj_inertia_traj_inertia_is_in_range(float value);

/**
 * Pack message Axis_9_Get_Iq.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_get_iq_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_get_iq_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Get_Iq.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_get_iq_unpack(
    struct qpup_axis_9_get_iq_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_get_iq_iq_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_get_iq_iq_setpoint_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_get_iq_iq_setpoint_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_get_iq_iq_measured_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_get_iq_iq_measured_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_get_iq_iq_measured_is_in_range(float value);

/**
 * Pack message Axis_9_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_get_sensorless_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_get_sensorless_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_get_sensorless_estimates_unpack(
    struct qpup_axis_9_get_sensorless_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_get_sensorless_estimates_sensorless_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_get_sensorless_estimates_sensorless_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_get_sensorless_estimates_sensorless_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_get_sensorless_estimates_sensorless_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_get_sensorless_estimates_sensorless_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_get_sensorless_estimates_sensorless_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_9_Reboot.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_reboot_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_reboot_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Reboot.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_reboot_unpack(
    struct qpup_axis_9_reboot_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_9_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_get_vbus_voltage_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_get_vbus_voltage_unpack(
    struct qpup_axis_9_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_get_vbus_voltage_vbus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_get_vbus_voltage_vbus_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_get_vbus_voltage_vbus_voltage_is_in_range(float value);

/**
 * Pack message Axis_9_Clear_Errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_clear_errors_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Clear_Errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_clear_errors_unpack(
    struct qpup_axis_9_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_9_Set_Linear_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_set_linear_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_set_linear_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Set_Linear_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_set_linear_count_unpack(
    struct qpup_axis_9_set_linear_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t qpup_axis_9_set_linear_count_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_linear_count_position_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_linear_count_position_is_in_range(int32_t value);

/**
 * Pack message Axis_9_Set_Pos_Gain.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_set_pos_gain_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_set_pos_gain_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Set_Pos_Gain.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_set_pos_gain_unpack(
    struct qpup_axis_9_set_pos_gain_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_set_pos_gain_pos_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_pos_gain_pos_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_pos_gain_pos_gain_is_in_range(float value);

/**
 * Pack message Axis_9_Set_Vel_gains.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_9_set_vel_gains_pack(
    uint8_t *dst_p,
    const struct qpup_axis_9_set_vel_gains_t *src_p,
    size_t size);

/**
 * Unpack message Axis_9_Set_Vel_gains.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_9_set_vel_gains_unpack(
    struct qpup_axis_9_set_vel_gains_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_set_vel_gains_vel_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_vel_gains_vel_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_vel_gains_vel_gain_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_9_set_vel_gains_vel_integrator_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_9_set_vel_gains_vel_integrator_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_9_set_vel_gains_vel_integrator_gain_is_in_range(float value);

/**
 * Pack message Axis_10_Heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_heartbeat_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_heartbeat_unpack(
    struct qpup_axis_10_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_10_heartbeat_axis_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_heartbeat_axis_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_heartbeat_axis_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_10_heartbeat_axis_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_heartbeat_axis_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_heartbeat_axis_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_10_heartbeat_motor_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_heartbeat_motor_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_heartbeat_motor_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_10_heartbeat_encoder_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_heartbeat_encoder_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_heartbeat_encoder_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_10_heartbeat_controller_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_heartbeat_controller_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_heartbeat_controller_flags_is_in_range(uint8_t value);

/**
 * Pack message Axis_10_Estop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_estop_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_estop_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Estop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_estop_unpack(
    struct qpup_axis_10_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_10_Get_Motor_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_get_motor_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_get_motor_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Get_Motor_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_get_motor_error_unpack(
    struct qpup_axis_10_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_10_get_motor_error_motor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_get_motor_error_motor_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_get_motor_error_motor_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_10_Get_Encoder_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_get_encoder_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Get_Encoder_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_get_encoder_error_unpack(
    struct qpup_axis_10_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_10_get_encoder_error_encoder_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_get_encoder_error_encoder_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_get_encoder_error_encoder_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_10_Get_Sensorless_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_get_sensorless_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_get_sensorless_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Get_Sensorless_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_get_sensorless_error_unpack(
    struct qpup_axis_10_get_sensorless_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_10_get_sensorless_error_sensorless_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_get_sensorless_error_sensorless_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_get_sensorless_error_sensorless_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_10_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_set_axis_node_id_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_set_axis_node_id_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_set_axis_node_id_unpack(
    struct qpup_axis_10_set_axis_node_id_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_10_set_axis_node_id_axis_node_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_axis_node_id_axis_node_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_axis_node_id_axis_node_id_is_in_range(uint32_t value);

/**
 * Pack message Axis_10_Set_Axis_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_set_axis_state_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_set_axis_state_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Set_Axis_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_set_axis_state_unpack(
    struct qpup_axis_10_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_10_set_axis_state_axis_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_axis_state_axis_requested_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_axis_state_axis_requested_state_is_in_range(uint32_t value);

/**
 * Pack message Axis_10_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_get_encoder_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_get_encoder_estimates_unpack(
    struct qpup_axis_10_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_get_encoder_estimates_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_get_encoder_estimates_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_get_encoder_estimates_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_get_encoder_estimates_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_get_encoder_estimates_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_get_encoder_estimates_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_10_Get_Encoder_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_get_encoder_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Get_Encoder_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_get_encoder_count_unpack(
    struct qpup_axis_10_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_10_get_encoder_count_shadow_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_get_encoder_count_shadow_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_get_encoder_count_shadow_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_10_get_encoder_count_count_in_cpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_get_encoder_count_count_in_cpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_get_encoder_count_count_in_cpr_is_in_range(uint32_t value);

/**
 * Pack message Axis_10_Set_Controller_Mode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_set_controller_mode_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Set_Controller_Mode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_set_controller_mode_unpack(
    struct qpup_axis_10_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_10_set_controller_mode_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_controller_mode_control_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_controller_mode_control_mode_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_10_set_controller_mode_input_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_controller_mode_input_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_controller_mode_input_mode_is_in_range(uint32_t value);

/**
 * Pack message Axis_10_Set_Input_Pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_set_input_pos_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_set_input_pos_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Set_Input_Pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_set_input_pos_unpack(
    struct qpup_axis_10_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_set_input_pos_input_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_input_pos_input_pos_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_input_pos_input_pos_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_10_set_input_pos_vel_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_input_pos_vel_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_input_pos_vel_ff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_10_set_input_pos_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_input_pos_torque_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_input_pos_torque_ff_is_in_range(int16_t value);

/**
 * Pack message Axis_10_Set_Input_Vel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_set_input_vel_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_set_input_vel_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Set_Input_Vel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_set_input_vel_unpack(
    struct qpup_axis_10_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_set_input_vel_input_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_input_vel_input_vel_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_input_vel_input_vel_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_set_input_vel_input_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_input_vel_input_torque_ff_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_input_vel_input_torque_ff_is_in_range(float value);

/**
 * Pack message Axis_10_Set_Input_Torque.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_set_input_torque_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_set_input_torque_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Set_Input_Torque.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_set_input_torque_unpack(
    struct qpup_axis_10_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_set_input_torque_input_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_input_torque_input_torque_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_input_torque_input_torque_is_in_range(float value);

/**
 * Pack message Axis_10_Set_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_set_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_set_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Set_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_set_limits_unpack(
    struct qpup_axis_10_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_set_limits_velocity_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_limits_velocity_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_limits_velocity_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_set_limits_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_limits_current_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_limits_current_limit_is_in_range(float value);

/**
 * Pack message Axis_10_Start_Anticogging.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_start_anticogging_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_start_anticogging_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Start_Anticogging.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_start_anticogging_unpack(
    struct qpup_axis_10_start_anticogging_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_10_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_set_traj_vel_limit_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_set_traj_vel_limit_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_set_traj_vel_limit_unpack(
    struct qpup_axis_10_set_traj_vel_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_set_traj_vel_limit_traj_vel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_traj_vel_limit_traj_vel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_traj_vel_limit_traj_vel_limit_is_in_range(float value);

/**
 * Pack message Axis_10_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_set_traj_accel_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_set_traj_accel_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_set_traj_accel_limits_unpack(
    struct qpup_axis_10_set_traj_accel_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_set_traj_accel_limits_traj_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_traj_accel_limits_traj_accel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_traj_accel_limits_traj_accel_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_set_traj_accel_limits_traj_decel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_traj_accel_limits_traj_decel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_traj_accel_limits_traj_decel_limit_is_in_range(float value);

/**
 * Pack message Axis_10_Set_Traj_Inertia.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_set_traj_inertia_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_set_traj_inertia_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Set_Traj_Inertia.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_set_traj_inertia_unpack(
    struct qpup_axis_10_set_traj_inertia_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_set_traj_inertia_traj_inertia_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_traj_inertia_traj_inertia_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_traj_inertia_traj_inertia_is_in_range(float value);

/**
 * Pack message Axis_10_Get_Iq.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_get_iq_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_get_iq_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Get_Iq.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_get_iq_unpack(
    struct qpup_axis_10_get_iq_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_get_iq_iq_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_get_iq_iq_setpoint_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_get_iq_iq_setpoint_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_get_iq_iq_measured_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_get_iq_iq_measured_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_get_iq_iq_measured_is_in_range(float value);

/**
 * Pack message Axis_10_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_get_sensorless_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_get_sensorless_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_get_sensorless_estimates_unpack(
    struct qpup_axis_10_get_sensorless_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_get_sensorless_estimates_sensorless_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_get_sensorless_estimates_sensorless_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_get_sensorless_estimates_sensorless_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_get_sensorless_estimates_sensorless_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_get_sensorless_estimates_sensorless_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_get_sensorless_estimates_sensorless_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_10_Reboot.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_reboot_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_reboot_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Reboot.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_reboot_unpack(
    struct qpup_axis_10_reboot_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_10_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_get_vbus_voltage_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_get_vbus_voltage_unpack(
    struct qpup_axis_10_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_get_vbus_voltage_vbus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_get_vbus_voltage_vbus_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_get_vbus_voltage_vbus_voltage_is_in_range(float value);

/**
 * Pack message Axis_10_Clear_Errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_clear_errors_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Clear_Errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_clear_errors_unpack(
    struct qpup_axis_10_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_10_Set_Linear_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_set_linear_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_set_linear_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Set_Linear_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_set_linear_count_unpack(
    struct qpup_axis_10_set_linear_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t qpup_axis_10_set_linear_count_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_linear_count_position_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_linear_count_position_is_in_range(int32_t value);

/**
 * Pack message Axis_10_Set_Pos_Gain.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_set_pos_gain_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_set_pos_gain_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Set_Pos_Gain.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_set_pos_gain_unpack(
    struct qpup_axis_10_set_pos_gain_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_set_pos_gain_pos_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_pos_gain_pos_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_pos_gain_pos_gain_is_in_range(float value);

/**
 * Pack message Axis_10_Set_Vel_gains.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_10_set_vel_gains_pack(
    uint8_t *dst_p,
    const struct qpup_axis_10_set_vel_gains_t *src_p,
    size_t size);

/**
 * Unpack message Axis_10_Set_Vel_gains.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_10_set_vel_gains_unpack(
    struct qpup_axis_10_set_vel_gains_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_set_vel_gains_vel_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_vel_gains_vel_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_vel_gains_vel_gain_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_10_set_vel_gains_vel_integrator_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_10_set_vel_gains_vel_integrator_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_10_set_vel_gains_vel_integrator_gain_is_in_range(float value);

/**
 * Pack message Axis_11_Heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_heartbeat_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_heartbeat_unpack(
    struct qpup_axis_11_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_11_heartbeat_axis_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_heartbeat_axis_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_heartbeat_axis_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_11_heartbeat_axis_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_heartbeat_axis_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_heartbeat_axis_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_11_heartbeat_motor_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_heartbeat_motor_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_heartbeat_motor_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_11_heartbeat_encoder_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_heartbeat_encoder_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_heartbeat_encoder_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_11_heartbeat_controller_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_heartbeat_controller_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_heartbeat_controller_flags_is_in_range(uint8_t value);

/**
 * Pack message Axis_11_Estop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_estop_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_estop_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Estop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_estop_unpack(
    struct qpup_axis_11_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_11_Get_Motor_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_get_motor_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_get_motor_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Get_Motor_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_get_motor_error_unpack(
    struct qpup_axis_11_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_11_get_motor_error_motor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_get_motor_error_motor_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_get_motor_error_motor_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_11_Get_Encoder_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_get_encoder_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Get_Encoder_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_get_encoder_error_unpack(
    struct qpup_axis_11_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_11_get_encoder_error_encoder_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_get_encoder_error_encoder_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_get_encoder_error_encoder_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_11_Get_Sensorless_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_get_sensorless_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_get_sensorless_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Get_Sensorless_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_get_sensorless_error_unpack(
    struct qpup_axis_11_get_sensorless_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_11_get_sensorless_error_sensorless_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_get_sensorless_error_sensorless_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_get_sensorless_error_sensorless_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_11_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_set_axis_node_id_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_set_axis_node_id_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_set_axis_node_id_unpack(
    struct qpup_axis_11_set_axis_node_id_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_11_set_axis_node_id_axis_node_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_axis_node_id_axis_node_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_axis_node_id_axis_node_id_is_in_range(uint32_t value);

/**
 * Pack message Axis_11_Set_Axis_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_set_axis_state_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_set_axis_state_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Set_Axis_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_set_axis_state_unpack(
    struct qpup_axis_11_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_11_set_axis_state_axis_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_axis_state_axis_requested_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_axis_state_axis_requested_state_is_in_range(uint32_t value);

/**
 * Pack message Axis_11_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_get_encoder_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_get_encoder_estimates_unpack(
    struct qpup_axis_11_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_get_encoder_estimates_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_get_encoder_estimates_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_get_encoder_estimates_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_get_encoder_estimates_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_get_encoder_estimates_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_get_encoder_estimates_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_11_Get_Encoder_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_get_encoder_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Get_Encoder_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_get_encoder_count_unpack(
    struct qpup_axis_11_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_11_get_encoder_count_shadow_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_get_encoder_count_shadow_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_get_encoder_count_shadow_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_11_get_encoder_count_count_in_cpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_get_encoder_count_count_in_cpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_get_encoder_count_count_in_cpr_is_in_range(uint32_t value);

/**
 * Pack message Axis_11_Set_Controller_Mode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_set_controller_mode_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Set_Controller_Mode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_set_controller_mode_unpack(
    struct qpup_axis_11_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_11_set_controller_mode_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_controller_mode_control_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_controller_mode_control_mode_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_11_set_controller_mode_input_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_controller_mode_input_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_controller_mode_input_mode_is_in_range(uint32_t value);

/**
 * Pack message Axis_11_Set_Input_Pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_set_input_pos_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_set_input_pos_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Set_Input_Pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_set_input_pos_unpack(
    struct qpup_axis_11_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_set_input_pos_input_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_input_pos_input_pos_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_input_pos_input_pos_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_11_set_input_pos_vel_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_input_pos_vel_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_input_pos_vel_ff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_11_set_input_pos_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_input_pos_torque_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_input_pos_torque_ff_is_in_range(int16_t value);

/**
 * Pack message Axis_11_Set_Input_Vel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_set_input_vel_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_set_input_vel_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Set_Input_Vel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_set_input_vel_unpack(
    struct qpup_axis_11_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_set_input_vel_input_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_input_vel_input_vel_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_input_vel_input_vel_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_set_input_vel_input_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_input_vel_input_torque_ff_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_input_vel_input_torque_ff_is_in_range(float value);

/**
 * Pack message Axis_11_Set_Input_Torque.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_set_input_torque_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_set_input_torque_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Set_Input_Torque.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_set_input_torque_unpack(
    struct qpup_axis_11_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_set_input_torque_input_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_input_torque_input_torque_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_input_torque_input_torque_is_in_range(float value);

/**
 * Pack message Axis_11_Set_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_set_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_set_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Set_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_set_limits_unpack(
    struct qpup_axis_11_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_set_limits_velocity_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_limits_velocity_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_limits_velocity_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_set_limits_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_limits_current_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_limits_current_limit_is_in_range(float value);

/**
 * Pack message Axis_11_Start_Anticogging.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_start_anticogging_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_start_anticogging_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Start_Anticogging.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_start_anticogging_unpack(
    struct qpup_axis_11_start_anticogging_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_11_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_set_traj_vel_limit_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_set_traj_vel_limit_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_set_traj_vel_limit_unpack(
    struct qpup_axis_11_set_traj_vel_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_set_traj_vel_limit_traj_vel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_traj_vel_limit_traj_vel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_traj_vel_limit_traj_vel_limit_is_in_range(float value);

/**
 * Pack message Axis_11_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_set_traj_accel_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_set_traj_accel_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_set_traj_accel_limits_unpack(
    struct qpup_axis_11_set_traj_accel_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_set_traj_accel_limits_traj_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_traj_accel_limits_traj_accel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_traj_accel_limits_traj_accel_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_set_traj_accel_limits_traj_decel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_traj_accel_limits_traj_decel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_traj_accel_limits_traj_decel_limit_is_in_range(float value);

/**
 * Pack message Axis_11_Set_Traj_Inertia.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_set_traj_inertia_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_set_traj_inertia_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Set_Traj_Inertia.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_set_traj_inertia_unpack(
    struct qpup_axis_11_set_traj_inertia_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_set_traj_inertia_traj_inertia_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_traj_inertia_traj_inertia_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_traj_inertia_traj_inertia_is_in_range(float value);

/**
 * Pack message Axis_11_Get_Iq.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_get_iq_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_get_iq_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Get_Iq.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_get_iq_unpack(
    struct qpup_axis_11_get_iq_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_get_iq_iq_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_get_iq_iq_setpoint_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_get_iq_iq_setpoint_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_get_iq_iq_measured_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_get_iq_iq_measured_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_get_iq_iq_measured_is_in_range(float value);

/**
 * Pack message Axis_11_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_get_sensorless_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_get_sensorless_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_get_sensorless_estimates_unpack(
    struct qpup_axis_11_get_sensorless_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_get_sensorless_estimates_sensorless_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_get_sensorless_estimates_sensorless_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_get_sensorless_estimates_sensorless_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_get_sensorless_estimates_sensorless_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_get_sensorless_estimates_sensorless_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_get_sensorless_estimates_sensorless_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_11_Reboot.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_reboot_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_reboot_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Reboot.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_reboot_unpack(
    struct qpup_axis_11_reboot_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_11_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_get_vbus_voltage_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_get_vbus_voltage_unpack(
    struct qpup_axis_11_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_get_vbus_voltage_vbus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_get_vbus_voltage_vbus_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_get_vbus_voltage_vbus_voltage_is_in_range(float value);

/**
 * Pack message Axis_11_Clear_Errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_clear_errors_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Clear_Errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_clear_errors_unpack(
    struct qpup_axis_11_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_11_Set_Linear_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_set_linear_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_set_linear_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Set_Linear_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_set_linear_count_unpack(
    struct qpup_axis_11_set_linear_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t qpup_axis_11_set_linear_count_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_linear_count_position_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_linear_count_position_is_in_range(int32_t value);

/**
 * Pack message Axis_11_Set_Pos_Gain.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_set_pos_gain_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_set_pos_gain_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Set_Pos_Gain.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_set_pos_gain_unpack(
    struct qpup_axis_11_set_pos_gain_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_set_pos_gain_pos_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_pos_gain_pos_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_pos_gain_pos_gain_is_in_range(float value);

/**
 * Pack message Axis_11_Set_Vel_gains.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_11_set_vel_gains_pack(
    uint8_t *dst_p,
    const struct qpup_axis_11_set_vel_gains_t *src_p,
    size_t size);

/**
 * Unpack message Axis_11_Set_Vel_gains.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_11_set_vel_gains_unpack(
    struct qpup_axis_11_set_vel_gains_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_set_vel_gains_vel_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_vel_gains_vel_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_vel_gains_vel_gain_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_11_set_vel_gains_vel_integrator_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_11_set_vel_gains_vel_integrator_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_11_set_vel_gains_vel_integrator_gain_is_in_range(float value);

/**
 * Pack message Axis_12_Heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_heartbeat_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_heartbeat_unpack(
    struct qpup_axis_12_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_12_heartbeat_axis_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_heartbeat_axis_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_heartbeat_axis_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_12_heartbeat_axis_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_heartbeat_axis_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_heartbeat_axis_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_12_heartbeat_motor_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_heartbeat_motor_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_heartbeat_motor_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_12_heartbeat_encoder_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_heartbeat_encoder_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_heartbeat_encoder_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t qpup_axis_12_heartbeat_controller_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_heartbeat_controller_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_heartbeat_controller_flags_is_in_range(uint8_t value);

/**
 * Pack message Axis_12_Estop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_estop_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_estop_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Estop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_estop_unpack(
    struct qpup_axis_12_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_12_Get_Motor_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_get_motor_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_get_motor_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Get_Motor_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_get_motor_error_unpack(
    struct qpup_axis_12_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_12_get_motor_error_motor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_get_motor_error_motor_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_get_motor_error_motor_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_12_Get_Encoder_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_get_encoder_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Get_Encoder_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_get_encoder_error_unpack(
    struct qpup_axis_12_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_12_get_encoder_error_encoder_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_get_encoder_error_encoder_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_get_encoder_error_encoder_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_12_Get_Sensorless_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_get_sensorless_error_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_get_sensorless_error_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Get_Sensorless_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_get_sensorless_error_unpack(
    struct qpup_axis_12_get_sensorless_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_12_get_sensorless_error_sensorless_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_get_sensorless_error_sensorless_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_get_sensorless_error_sensorless_error_is_in_range(uint32_t value);

/**
 * Pack message Axis_12_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_set_axis_node_id_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_set_axis_node_id_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Set_Axis_Node_ID.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_set_axis_node_id_unpack(
    struct qpup_axis_12_set_axis_node_id_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_12_set_axis_node_id_axis_node_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_axis_node_id_axis_node_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_axis_node_id_axis_node_id_is_in_range(uint32_t value);

/**
 * Pack message Axis_12_Set_Axis_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_set_axis_state_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_set_axis_state_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Set_Axis_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_set_axis_state_unpack(
    struct qpup_axis_12_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_12_set_axis_state_axis_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_axis_state_axis_requested_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_axis_state_axis_requested_state_is_in_range(uint32_t value);

/**
 * Pack message Axis_12_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_get_encoder_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Get_Encoder_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_get_encoder_estimates_unpack(
    struct qpup_axis_12_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_get_encoder_estimates_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_get_encoder_estimates_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_get_encoder_estimates_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_get_encoder_estimates_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_get_encoder_estimates_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_get_encoder_estimates_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_12_Get_Encoder_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_get_encoder_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Get_Encoder_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_get_encoder_count_unpack(
    struct qpup_axis_12_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_12_get_encoder_count_shadow_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_get_encoder_count_shadow_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_get_encoder_count_shadow_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_12_get_encoder_count_count_in_cpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_get_encoder_count_count_in_cpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_get_encoder_count_count_in_cpr_is_in_range(uint32_t value);

/**
 * Pack message Axis_12_Set_Controller_Mode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_set_controller_mode_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Set_Controller_Mode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_set_controller_mode_unpack(
    struct qpup_axis_12_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_12_set_controller_mode_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_controller_mode_control_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_controller_mode_control_mode_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t qpup_axis_12_set_controller_mode_input_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_controller_mode_input_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_controller_mode_input_mode_is_in_range(uint32_t value);

/**
 * Pack message Axis_12_Set_Input_Pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_set_input_pos_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_set_input_pos_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Set_Input_Pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_set_input_pos_unpack(
    struct qpup_axis_12_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_set_input_pos_input_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_input_pos_input_pos_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_input_pos_input_pos_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_12_set_input_pos_vel_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_input_pos_vel_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_input_pos_vel_ff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t qpup_axis_12_set_input_pos_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_input_pos_torque_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_input_pos_torque_ff_is_in_range(int16_t value);

/**
 * Pack message Axis_12_Set_Input_Vel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_set_input_vel_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_set_input_vel_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Set_Input_Vel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_set_input_vel_unpack(
    struct qpup_axis_12_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_set_input_vel_input_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_input_vel_input_vel_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_input_vel_input_vel_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_set_input_vel_input_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_input_vel_input_torque_ff_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_input_vel_input_torque_ff_is_in_range(float value);

/**
 * Pack message Axis_12_Set_Input_Torque.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_set_input_torque_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_set_input_torque_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Set_Input_Torque.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_set_input_torque_unpack(
    struct qpup_axis_12_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_set_input_torque_input_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_input_torque_input_torque_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_input_torque_input_torque_is_in_range(float value);

/**
 * Pack message Axis_12_Set_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_set_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_set_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Set_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_set_limits_unpack(
    struct qpup_axis_12_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_set_limits_velocity_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_limits_velocity_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_limits_velocity_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_set_limits_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_limits_current_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_limits_current_limit_is_in_range(float value);

/**
 * Pack message Axis_12_Start_Anticogging.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_start_anticogging_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_start_anticogging_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Start_Anticogging.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_start_anticogging_unpack(
    struct qpup_axis_12_start_anticogging_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_12_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_set_traj_vel_limit_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_set_traj_vel_limit_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_set_traj_vel_limit_unpack(
    struct qpup_axis_12_set_traj_vel_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_set_traj_vel_limit_traj_vel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_traj_vel_limit_traj_vel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_traj_vel_limit_traj_vel_limit_is_in_range(float value);

/**
 * Pack message Axis_12_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_set_traj_accel_limits_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_set_traj_accel_limits_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_set_traj_accel_limits_unpack(
    struct qpup_axis_12_set_traj_accel_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_set_traj_accel_limits_traj_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_traj_accel_limits_traj_accel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_traj_accel_limits_traj_accel_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_set_traj_accel_limits_traj_decel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_traj_accel_limits_traj_decel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_traj_accel_limits_traj_decel_limit_is_in_range(float value);

/**
 * Pack message Axis_12_Set_Traj_Inertia.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_set_traj_inertia_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_set_traj_inertia_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Set_Traj_Inertia.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_set_traj_inertia_unpack(
    struct qpup_axis_12_set_traj_inertia_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_set_traj_inertia_traj_inertia_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_traj_inertia_traj_inertia_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_traj_inertia_traj_inertia_is_in_range(float value);

/**
 * Pack message Axis_12_Get_Iq.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_get_iq_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_get_iq_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Get_Iq.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_get_iq_unpack(
    struct qpup_axis_12_get_iq_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_get_iq_iq_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_get_iq_iq_setpoint_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_get_iq_iq_setpoint_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_get_iq_iq_measured_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_get_iq_iq_measured_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_get_iq_iq_measured_is_in_range(float value);

/**
 * Pack message Axis_12_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_get_sensorless_estimates_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_get_sensorless_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_get_sensorless_estimates_unpack(
    struct qpup_axis_12_get_sensorless_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_get_sensorless_estimates_sensorless_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_get_sensorless_estimates_sensorless_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_get_sensorless_estimates_sensorless_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_get_sensorless_estimates_sensorless_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_get_sensorless_estimates_sensorless_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_get_sensorless_estimates_sensorless_vel_estimate_is_in_range(float value);

/**
 * Pack message Axis_12_Reboot.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_reboot_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_reboot_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Reboot.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_reboot_unpack(
    struct qpup_axis_12_reboot_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_12_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_get_vbus_voltage_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Get_Vbus_Voltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_get_vbus_voltage_unpack(
    struct qpup_axis_12_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_get_vbus_voltage_vbus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_get_vbus_voltage_vbus_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_get_vbus_voltage_vbus_voltage_is_in_range(float value);

/**
 * Pack message Axis_12_Clear_Errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_clear_errors_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Clear_Errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_clear_errors_unpack(
    struct qpup_axis_12_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Axis_12_Set_Linear_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_set_linear_count_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_set_linear_count_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Set_Linear_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_set_linear_count_unpack(
    struct qpup_axis_12_set_linear_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t qpup_axis_12_set_linear_count_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_linear_count_position_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_linear_count_position_is_in_range(int32_t value);

/**
 * Pack message Axis_12_Set_Pos_Gain.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_set_pos_gain_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_set_pos_gain_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Set_Pos_Gain.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_set_pos_gain_unpack(
    struct qpup_axis_12_set_pos_gain_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_set_pos_gain_pos_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_pos_gain_pos_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_pos_gain_pos_gain_is_in_range(float value);

/**
 * Pack message Axis_12_Set_Vel_gains.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int qpup_axis_12_set_vel_gains_pack(
    uint8_t *dst_p,
    const struct qpup_axis_12_set_vel_gains_t *src_p,
    size_t size);

/**
 * Unpack message Axis_12_Set_Vel_gains.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int qpup_axis_12_set_vel_gains_unpack(
    struct qpup_axis_12_set_vel_gains_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_set_vel_gains_vel_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_vel_gains_vel_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_vel_gains_vel_gain_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float qpup_axis_12_set_vel_gains_vel_integrator_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double qpup_axis_12_set_vel_gains_vel_integrator_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool qpup_axis_12_set_vel_gains_vel_integrator_gain_is_in_range(float value);


#ifdef __cplusplus
}
#endif

#endif
